## 0000-全文背诵

### 一、HTML

#### 1.对HTML语义化的理解

语义化的含义就是用正确的标签做正确的事情；在没有样式的情况下也可以以一种文档格式显示，便于浏览器和搜索引擎的解析，有利于seo；使阅读源代码的人更容易将网站分块，便于阅读和维护。

#### 2.HTML5都有哪些更新

- 新增语义化标签：nav、header、footer、aside、section、article
- 音频、视频标签：audio、video
- 数据存储：localStorage、sessionStorage
- canvas（画布）、Geolocation（地理定位）、websocket（通信协议）
- input 标签新增属性：placeholder、autocomplete、autofocus、required
- history API：go、forward、back、pushstate

### 二、CSS

#### 1.对盒模型的理解

盒模型分为标准盒模型和IE 盒模型，标准盒模型中元素width和height属性只包含了元素的content，而IE盒模型不仅包含了content，还包含了border、padding

可以通过设置box-sizing的属性来改变元素的盒模型，content-box表示标准盒模型，border-box表示IE盒模型

#### 2.隐藏元素的方法有哪些

- **opacity: 0;**：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件
- **display: none**：渲染树不会包含该渲染对象，因此该元素不会在页面中占据空间，也不会响应绑定的监听事件。
- **visibility: hidden**：元素在页面中仍占据空间，但是不会响应绑定的监听事件。
- **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素在页面中仍然占据空间，但是不会响应绑定的监听事件。
- **position: absolute**：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
- **z-index: 负值**：来使其他元素遮盖住该元素，以此来实现隐藏。

#### 3.对BFC的理解

BFC 是⻚⾯中独立的⼀块渲染区域，有自己的⼀套渲染规则，BFC 中的元素布局不受外部影响；

**触发BFC的条件**

- 根元素：body；
- 元素设置浮动：float 除 none 以外的值；
- 元素设置绝对定位：position (absolute、fixed)；
- display 值为：inline-block、table-cell、table-caption、flex 等；
- overflow 值为：hidden、auto、scroll；

**BFC的特点**

- 在 BFC 中上下相邻的两个容器的 margin 会重叠
- 计算 BFC 的高度时，需要计算BFC中浮动元素的高度
- BFC 区域不会与浮动的容器发生重叠
- BFC 是独立的容器，容器内部元素不会影响外部元素

**BFC 的作用**

- **解决 margin 的重叠问题**：由于 BFC 是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个 BFC，就解决了 margin 重叠的问题。
- **解决高度塌陷的问题**：在对子元素设置浮动后，父元素会发生高度塌陷。只需要把父元素变成一个 BFC就可以解决这个问题。常用的办法是给父元素设置`overflow:hidden`。

#### 4.CSS3中新增了哪些新特性

- border-radius：圆角
- box-shadow：用于向方框添加阴影

- transform：可对元素进行位移、旋转、缩放、倾斜等
- animation：新增的动画效果属性
- transition：过渡效果
- 媒体查询
- flex布局、Grid栅格布局

#### 5.对flex的理解

**flex是一个弹性布局**，用 Flex 布局的元素，称为 Flex 容器，它的所有子元素自动成为容器成员，称为 Flex item；容器默认存在两根轴：水平的主轴和垂直的交叉轴，项目默认沿水平主轴排列。

**容器上的属性**

- flex-direction 属性决定主轴的方向（即项目的排列方向）。
- flex-wrap 属性定义，如果一条轴线排不下，如何换行。
- flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。
- justify-content 属性定义了项目在主轴上的对齐方式。
- align-items 属性定义项目在交叉轴上的对齐方式。
- align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

**flex item上的属性**

- order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。
- flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。
- flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。
- flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。
- flex 属性是 flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。
- align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch

#### 6.垂直居中

- 对于行内元素，父级设置text-align:center;height与line-height的关系为line-height等于height除以要展示的行数;
- 对于块级元素
  - flex：父级设置 justify-content: center; align-items: center;即可
  - 绝对定位1：子绝父相，子元素设置top: 50%;left: 50%;transform: translate(-50%, -50%);
  - 绝对定位2：子绝父相，子元素设置ttop: 0;left: 0;right: 0;bottom: 0;margin: auto;

#### 7.两列布局(以左列定宽，右列自适应为例)

- flex：父级设置display: flex;右侧子元素设置:flex: 1;
- float：左侧子元素float: left;右侧子元素设置overflow: hidden;触发BFC；
- 绝对定位：左侧子元素position: absolute; top: 0; left: 0;右侧子元素margin-left: 左侧子元素的宽度;

#### 8.三列布局

- flex：父级设置display: flex;中间的子元素设置:flex: 1;
- 绝对定位：左侧子元素： position: absolute;top: 0;left: 0;右侧子元素：position: absolute; top: 0;right: 0;

​        中间元素：margin-left: 左侧子元素的宽度; margin-right: 右侧子元素的宽度;

- 浮动：左侧子元素float: left;右侧子元素float: right;中间元素：overflow:hidden;触发BFC，注意中间的子元素需要在右侧子元素的下方
- 圣杯布局：给所有子元素添加浮动，中间元素宽度设为100%，左右为定宽，且左元素的margin-left设为-100%，并设相对定位left-左侧的宽度，右元素的margin-right设为-右侧元素的宽度，并设相对定位right-右侧的宽度，父元素的margin-left：左侧元素的宽度、margin-right：右侧元素的宽度
- 双飞翼布局：给所有子元素添加浮动，中间元素宽度设为100%，左右为定宽，且左元素的margin-left设为-100%，左元素的margin-left设为-右侧元素的宽度，在中间元素中加个inner元素，设置其margin-left：左侧元素的宽度、margin-right：右侧元素的宽度

### 三、JavaScript基础

#### 1.数据类型的检测方式有哪些

1. typeof用来判断基础数据类型

2. instanceof，判断在其原型链上能否找到该类型的原型

  适用于判断引用数据类型，不适用于判断基础数据类型，且Object在所有的引用类型的原型上

3. `constructor`有两个作用，一是判断数据的类型，二是对象实例通过 `constrcutor` 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，`constructor`就不能用来判断数据类型了

4. Object.prototype.toString.call()，可以判断所有的数据类型

5. 全等 ===

#### 2.为什么0.1+0.2 !== 0.3

计算机是通过二进制来存储数据的，0.1和0.2换算成二进制为无限循环的二进制小数，JavaScript采用双精度浮点数来存储数字，使用64位固定长度来表示，其中数字（分数）存储在位 0 到位 51 中，指数存储在位 52 到位 62 中，符号存储在位 63 中。0.1 + 0.2 后会截取52位有效数字（53位数字采用1进0舍的方法），因此存在一定的精度流失导致0.1+0.2 !== 0.3。

其中数字（分数）存储在位 0 到 51 中，指数存储在位 52 到 62 中，符号存储在位 63 中。

符号位用 0表示负数，1表示正数

指数位，由于IEEE固定**双精度数的偏移量为1023**，所以用指数位+偏移量再转换为2进制即为指数位的大小

小数位，通过科学计数法去掉前面的零之后的数字即为小数位。

#### 3.隐式类型的转换规则

隐式转换主要分为三种方式：

- 将引用类型的值转化为原始值 => toPrimitive
- 将原始值转化为String => ToString
- 将原始值转化为Number => ToNumber

默认情况下，调用toPrimitive方法，若引用类型为Date则为string类型，即先调用toString()方法再调用valueof()方法，其他引用类型是先调用valueof方法，再调用toString()方法

Date的valueof方法返回一个时间戳，其他对象的valueof方法返回原对象

数组的tostring方法将数组内的元素用逗号拼接并转换为字符串，Object的tostring方法返回'[object Object]'，Date的tostring方法返回'Mon Dec 13 2021 17:28:51 GMT+0800 (中国标准时间)'，其他对象类型的tostring方法都返回其初始化的字符串。

==操作符的类型转换规则

- 先判断类型是否相同，相同则比较两者的大小，不同则进行类型转换
- 再判断是否在对比 null 和 undefined，是的话就会返回 `true`，null只会等于undefined，undefined也只等于null
- 判断两者类型是否为 `string` 和 `number`，是的话就会将字符串转换为 `number`

- 判断其中一方是否为 `boolean`，是的话就会把 `boolean` 转为 `number` 再进行判断

- 判断其中一方是否为 `object` 且另一方为 `string`、`number` 或者 `symbol`，是的话就会把 `object` 转为原始类型再进行判断

**+操作符的强制类型转换规则**

+操作符`+`操作符的两边有至少一个`string`类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。

**-、*、\的强制类型转换规则**

会将变量都转换为数字再进行比较

**对于`<`和`>`比较符**

如果两边都是字符串，则比较字母表顺序，其他情况下，转换为数字再比较

#### 4.let、const、var的区别

1. 块级作用域：let、const有块级作用域，var没有
2. 变量提升：var存在变量提升，let、const不存在变量提升
3. 重复声明：var可以重复声明，let、const不可以重复声明
4. 初始值设置：var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。
5. 变量值的是否可修改：var 和 let 可以。而const不行。
6. 暂时性死区：在使用let、const命令声明变量之前，该变量都是不可用的。var声明的变量不存在暂时性死区
7. 给全局添加属性：var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会

#### 5.箭头函数的特点

1. 箭头函数比普通函数更加简洁
2. 箭头函数没有自己的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 
3. 箭头函数没有自己的arguments
4. 箭头函数没有prototype
5. 箭头函数不能作为构造函数使用
6. 箭头函数不能用作Generator函数，不能使用yeild关键字

### 四、JavaScript进阶

#### 1.闭包

闭包是一个定义在函数内部的子函数，这个子函数可以访问函数内部的变量；

闭包的用途：

- 可以创建私有变量，正常情况下函数内部的变量在函数外部不可访问，但是可以通过调用函数内部的子函数来访问函数内的变量。
- 使已经运行结束的函数上下文中的变量继续留在内存中，因为闭包函数保留了这个变量的引用，所以这个变量不会被回收。

弊端：容易造成内存泄漏

#### 2.执行上下文

JS分为全局执行上下文和函数执行上下文；

全局执行上下文：在执行JS全局代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。

函数执行上下文：在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。函数的上下文可以有任意多个

**执行上下文栈**

- JavaScript引擎使用执行上下文栈来管理执行上下文
- 当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文

#### 3.作用域链

查找变量时，首先在当前作用域中查找所需变量，若在该作用域中没有这个变量，就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链

#### 4.事件循环

JavaScript是单线程的，在JavaScript处理完同步代码后才再执行异步任务，异步任务还分为宏任务（setTimeout、setInterval）和微任务（Promise），当主线程执行完毕会先执行微任务，微任务执行完再执行宏任务。

#### 5.原型

原型是一个给其它对象提供共享属性的对象

**原型链：**当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去。原型链的尽头一般来说是 Object.prototype。

#### 6.继承

继承是指子类继承父类的属性和方法，便于代码的复用

- 原型继承
- call继承
- 组合继承
- 组合继承优化
- ES6继承

#### 7.垃圾回收

垃圾回收是一种内存管理的机制，当一个对象不再被引用时就成了垃圾，这时就需要将其释放，以让出内存。

浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。

**标记清除：**垃圾收集器会在内存中给所有变量都加上一个标记0，并从根元素对象开始遍历，若有引用到则标记为1，遍历完成后，会将标记为0的对象进行销毁并回收，然后等待下一次的标记清除

**引用计数法**：此算法会跟踪每一个对象的引用次数，当某个对象的引用次数为0时就会被销毁并回收。无法解决循环引用的问题

### 五、网络

#### 1.http版本历程

**http/0.9**

- 请求由单行指令构成： 例如：GET /mypage.html
- 只支持get方法，
- 只能传输HTML文件，
- 没有状态码

**HTTP/1.0**

- 引入了HTTP头的概念、具备了传输除纯文本HTML文件以外其他类型文档的能力
- 增加了状态码
- 协议版本信息现在会随着每个请求发送
- 支持get 、post等多种请求

**HTTP/1.1-标准化协议**

- 连接可以复用
- 引入额外的缓存控制机制。
- 引入内容协商机制，包括语言，编码，类型等
- 引入了Host头，能够使不同域名配置在同一个IP地址的服务器上
- 增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。

**HTTP/2.0**

- HTTP/2是二进制协议
- 这是一个复用协议。并行的请求能在同一个链接中处理
- 压缩了headers。
- 可以进行服务器推送

#### 2.https

HTTPS的通信过程如下：

1. 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
2. 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
3. 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
4. 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
5. 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。

#### 3.tcp的三次握手四次挥手

**三次握手**

- 客户端发送请求，进入SYN-SENT状态
- 服务端接收到请求后，如果同意连接则会发送一个应答，此时服务端进入SYN-RECEIVED 状态
- 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文，发送完报文后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功

四次挥手

- 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求
- 服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。
- 服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。
- 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

#### 4.HTTP状态码

**（1）2XX 成功**

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
- 206 Partial Content，进行范围请求

**（2）3XX 重定向**

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

**（3）4XX 客户端错误**

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

**（4）5XX 服务器错误**

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

#### 5.HTTP缓存

- 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
- 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，
- 如果资源已过期，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
- 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
- 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；

#### 6.在浏览器输入url后按回车会发生什么

- 域名解析：判断本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。如果没有则向DNS服务器查找该域名的ip地址
- 拿到IP地址后，浏览器会以一个随机端口向服务器发起TCP连接请求，经过三次握手后，建立了TCP连接
- TCP连接建立后会客户端开始发送HTTP请求，服务端处理请求并返回报文
- 浏览器拿到内容后，开始解析HTML，构建DOM树
- 解析CSS，生成CSS规则树
- 合并DOM树和CSS规则，生成render树 
- 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 
- 绘制render树（paint），绘制页面像素信息
- 断开TCP连接

### 六、前端安全

#### 1.XSS（跨站脚本攻击）

通过给浏览器注入恶意脚本来攻击用户

- DOM型xss：在用户操作DOM时给浏览器的DOM植入恶意代码，从而达到攻击效果
- 反射型xss：XSS代码出现在URL中，通过引诱用户点击一个到目标网站的恶意链接来实施攻击
- 存储型xss： 当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS

解决方案：

- 对用户的输入进行过滤
- 对用户的输入的数据进行转码
- 在cookie中设置HttpOnly属性，使js脚本无法读取到cookie信息

#### 2.CSRF（跨站请求伪造）

攻击者冒充用户发起请求，完成一些违背用户意愿的事情

解决方案：

- 使用token
- 使用验证码
- 启用referer 验证

#### 3.点击劫持

将一个危险网站设置透明，然后在其上方设置一个按钮，当你点击这个按钮的时候，就会触发底部恶意网站的某些事件。

解决方案：

- 设置http响应头 X-Frame-Options
- 使用CSP(Content Security Policy)内容安全策略

#### 4.不安全的第三方依赖

一些第三方的依赖或者插件存在很多安全性问题，会存在的漏洞

解决方案：

- 选择成熟安全的第三方依赖
- 使用自动化工具检查这些第三方代码有没有安全问题

#### 5.本地存储数据泄露

本地存储的信息很不安全容易被黑客获取

解决方案：

- 不在本地存储重要数据
- 放到cookie中的信息或者localStorage里的信息要进行加密

