浏览器渲染原理

##### 一、浏览器的组成

- 浏览器进程(主进程)
  - 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程
  - 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- 网络进程
  - 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- GPU进程
  - 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 插件进程
  - 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

##### 二、网络传输协议（传输层）

- udp协议
  - udp头保存着端口号，可以根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序；
  - 速度快但不能保证数据可靠性
- tcp协议
  - TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。
  - tcp的传输过程：
    - 建立连接阶段：tcp三次握手建立连接
    - 传输数据阶段：接收端需要对每个数据包进行确认操作，如果在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制
    - 断开连接阶段： 四次挥手断开连接

##### 三、http请求过程（应用层）

构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。

##### 四、从url到页面展示的过程

- url解析
- 判断缓存
- dns解析
- 如果是https则需要建立tls连接
- 三次握手后，建立tcp连接
- 发起网络请求

渲染过程

- 将html代码构建成DOM树
- 样式计算
  - 将获取的css文本转换成一个样式表，可以通过document.styleSheets获取
  - 转换样式表中的属性值，使其标准化
  - 利用css的继承和层叠规则计算每个dom节点的具体样式
- 构建布局树：将DOM树和CSSOM树结合，计算出DOM 树中可见元素的几何位置
- 对布局树进行分层，并生成分层树
- 图层绘制
- 为每个图层生成绘制列表，并将其提交到合成线程
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

##### 五、JavaScript执行机制

- 调用栈
- 词法环境，变量环境
- 词法作用域，作用域，作用域链
- 闭包
- 执行上下文this

##### 六、垃圾回收

v8引擎分成了两个区域进行垃圾回收，

一个是新生代，用于存放内存比较小的对象和新加入的对象，新生代的空间比较小，会将空间分为对象区域和空闲区域，当对象区域空间满的时候，进行垃圾回收，先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中，完成复制后，对象区域与空闲区域进行角色翻转，实现新生代区域的循环使用

一个是老生代，用于存放内存比较小的对象和经过两次垃圾回收仍处于活跃状态的对象，主要通过标记清除来实现垃圾的清除，清除之后会进行内存整理

优化算法：增量标记，为防止执行一次垃圾回收的时间过长造成浏览器卡顿，因此将一次垃圾回收拆分成多个区域，分次进行回收

##### 七、事件循环

浏览器中的渲染进程负责页面的渲染，而页面渲染涉及到DOM解析、CSS样式计算，布局、网络资源解析、鼠标点击事件等

- 浏览器通过渲染进程中的主线程来进行页面的渲染，所以渲染的任务是单线程执行的，
- 由于线程的执行过程中需要接受和处理新的任务，因此引入了事件循环机制来处理新的事件
- 由于需要接受其他线程发送过来的任务，因此引入了消息队列，消息队列里的一个个任务称为宏任务，将所有消息队列中的宏任务按照先进先出的顺序排列，在主线层中一个一个的按顺序执行
- 每个宏任务都包含了一个微任务队列，当当前宏任务执行完后，会去执行对应的微任务队列，微任务队列解决了任务优先级的问题，如果一个宏任务中产生了一个任务，此任务优先级比较高，如果加入到消息队列的末尾会造成此任务不能及时的处理，将此任务立即执行又会影响当前任务的执行效率，因此可以将此任务推到微任务队列中。
- 如上所示：一个宏任务加对应的微任务队列组成了一个事件循环

定时器任务

- 通过定时器发起的任务会被保存到延迟队列中，当主线程执行完当前任务后会根据发起时间和延迟时间计算出到期的任务，并执行这些到期的任务，再继续下一个循环

##### XMLHttpRequest实现

初始化XMLHttpRequest对象，配置其回调函数，打开请求，配置参数，发出请求，通过IPC交给网络进程处理，网络进程将资源下载后，将返回的状态封装成任务添加到消息队列末尾

宏任务

- 渲染事件（如解析 DOM、计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
- JavaScript 脚本执行事件；
- 网络请求完成、文件读写完成事件。

微任务

- MutationObserver
- Promise.resolve()、Promise.reject()

##### Promise、async await、generator的区别

Promise 通过回调函数延迟绑定、回调函数返回值穿透和错误“冒泡”，解决了嵌套调用和合并多个任务的错误处理。

generator（生成器）是一个可以暂停执行和恢复执行的函数，函数会返回一个生成器对象，通过调用对象的next方法执行函数，碰到yeild则暂停执行，内部原理是通过协程完成的，协程和父协程在主线程上不能同时运行，当执行next方法时执行generator创建的协程，碰到yeild，协程暂停运行，协程恢复运行，碰到return则关闭当前协程

async await，可以以同步的代码形式完成异步代码，实现方式是通过Promise加生成器的方式实现的，async， await会开启一个生成器，碰到await对象，会将暂停协程的运行，同时恢复父线程的运行，当promise.then的回调函数被激活后，会将主线程的控制权交给 当前协程，当前协程恢复执行

#### 八、网络

网络资源请求过程

1.Queuing，当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待

2.connection/SSL，tcp连接和SSL 握手的时间

3.第一字节时间（TTFB），从请求发出，到收到服务器第一个字节数据的时间

4.Content Download，第一字节时间到接收到全部响应数据所用的时间

- 排队时间过久，大概率是由浏览器为每个域名最多维护 6 个tcp连接导致的

  - 可以以让 1 个站点下面的资源放在多个域名下面
  - 使用http2

- 第一字节时间（TTFB）时间过久

  - 使用 CDN 来缓存一些静态文件
  - 减少一些不必要的 Cookie 数据信息

- Content Download 时间过久

  - 减少文件大小，比如文件压缩，拆分等


JS与html的加载执行过程

JS代码的加载和执行会阻塞HTML的解析，同时由于不知道JS的代码会不会操作CSS，因此JS的代码会等CSS加载完毕后再加载

CSS树不阻塞DOM树的解析，他们是并行执行

浏览器有一个预解析的线程，会用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

首屏优化性能瓶颈

- 首屏阶段
  - HTML解析
  - CSS下载与解析
  - JavaScript下载与解析
  - 生成 CSSOM 和 DOM
  - 合成布局树
  - 渲染
- 性能瓶颈
  - 下载 CSS 文件
  - 下载 JavaScript 文件
  - 执行 JavaScript



