浏览器渲染原理总结

#### 一、浏览器的组成

- **浏览器进程(主进程)**
  - 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**
  - 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **网络进程**
  - 主要负责页面的网络资源加载
- **GPU进程**
  - 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- **插件进程**
  - 主要是负责插件的运行

#### 二、从url到页面展示发生了什么?

- **导航阶段**
  - beforeunload 事件
  - url解析
  - 查找缓存（强缓存）
  - DNS解析
  - 如果是HTTPS则需要建立TLS 连接（对称加密，非对称加密过程）
  - 建立TCP连接（三次握手）
  - 如果是301、302、307则进行重定向
  - 客户端发起请求，浏览器响应请求并返回响应内容
  - 浏览器进程判断返回的content-type类型如果是html，则开始准备渲染进程
  - 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
  - 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。
- **渲染阶段**
  - 拿到html文件后开始构建DOM树
  - 构建CSSOM树（styleSheets）
  - 样式计算（继承与重叠）
  - 构建布局树（计算出DOM 树中可见元素的几何位置）
  - 分层，为特定的节点生成专用的图层，并生成一棵对应的图层树
  - 图层绘制，把一个图层的绘制拆分成很多小的绘制指令，把这些指令按照顺序组成一个待绘制列表
  - 栅格化（raster）操作，主线程把绘制列表提交给合成线程， 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
  - 合成线程发送绘制图块命令 DrawQuad 给浏览器进程，浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

#### 三、JavaScript的执行机制

- **执行上下文** 是 JavaScript 执行一段代码时的运行环境
- **变量环境** 执行上下文中用来存储变量的地方
  **词法环境** 执行上下文中用来定义标识符与特定变量和函数的关联关系
- **作用域与作用域链** 作用域是变量与函数的可访问范围，JavaScript 引擎向变量环境以及上级作用域查找变量的过程叫做作用域链
- **词法作用域** 词法作用域又叫静态作用域，JavaScript中的变量的值在其定义时就确定了
- **闭包** 当函数A中返回函数B，且函数B引用了函数A中的变量就形成了闭包
- **this** 用来指代当前的执行上下文

#### 四、V8工作原理

- **垃圾回收**
  - v8引擎分成了两个区域进行垃圾回收，
  - 新生代，用于存放内存比较小的对象和新加入的对象，新生代的空间比较小，会将空间分为对象区域和空闲区域，当对象区域空间满的时候，进行垃圾回收，先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中，完成复制后，对象区域与空闲区域进行角色翻转，实现新生代区域的循环使用
  - 老生代，用于存放内存比较小的对象和经过两次垃圾回收仍处于活跃状态的对象，主要通过标记清除来实现垃圾的清除，清除之后会进行内存整理
  - 优化算法：增量标记，为防止执行一次垃圾回收的时间过长造成浏览器卡顿，因此将一次垃圾回收拆分成多个区域，分次进行回收

- **V8 是如何执行一段 JavaScript 代码的**
  - V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。

#### 五、事件循环

- **宏任务**
  - 渲染事件（如解析 DOM、计算布局、绘制）；
  - 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
  - JavaScript 脚本执行事件；
  - 网络请求完成、文件读写完成事件。
  
- **微任务**

  - MutationObserver
  - Promise.resolve()、Promise.reject()

- **事件循环过程**

  - 浏览器通过渲染进程中进行页面的渲染，渲染过程中会产生很多任务，如：解析 DOM、页面绘制、用户交互事件、JavaScript 脚本执行事件、网络请求事件等。
  - 这些任务都是通过渲染进程的主线程来完成的，因此同一时间只能执行一个任务
  - 渲染主线程将这些任务都添加到消息队列中，在消息队列的任务，按照某种任务优先级进行排列，如：在DOM解析过程，DOM的解析和页面绘制等任务优先级较高，在页面绘制完成后，用户节点交互事件优先级较高，同等优先级则按照推入消息队列的顺序进行排列
  - 渲染主线程通过事件循环的机制，每次从消息队列的头部取出任务并执行
  - V8引擎还维护了一个微任务队列，在当前宏任务执行结束之前会执行微任务队列中的任务，将微任务队列中的任务执行完之后，才会执行下一个宏任务。

- ##### Promise、async await、generator的区别

  - Promise 通过回调函数延迟绑定、回调函数返回值穿透和错误“冒泡”，解决了嵌套调用和合并多个任务的错误处理。


  - generator（生成器）是一个可以暂停执行和恢复执行的函数，函数会返回一个生成器对象，通过调用对象的next方法执行函数，碰到yeild则暂停执行，内部原理是通过协程完成的，协程和父协程在主线程上不能同时运行，当执行next方法时执行generator创建的协程，碰到yeild，协程暂停运行，协程恢复运行，碰到return则关闭当前协程

  - async await，可以以同步的代码形式完成异步代码，实现方式是通过Promise加生成器的方式实现的，async， await会开启一个生成器，碰到await对象，会将暂停协程的运行，同时恢复父线程的运行，当promise.then的回调函数被激活后，会将主线程的控制权交给 当前协程，当前协程恢复执行
  - Promise 中为什么要引入微任务？
  - Promise 中是如何实现回调函数返回值穿透的？
  - Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？

#### 六、JS与html的加载执行过程

- JS代码的加载和执行会阻塞HTML的解析，同时由于不知道JS的代码会不会操作CSS，因此JS的代码会等CSS加载完毕后再加载
- CSS树不阻塞DOM树的解析，他们是并行执行
- async defer preload prefetch

#### 七、HTTP

http1.0、http1.1、http2.0、http3.0、https

#### 八、浏览器安全

#### 九、性能指标

**FP(白屏时间)**： 

从beforeUnload事件结束后，页面跳转开始到服务器开始返回html文件的时间

performance.timing: responseStart - navigationStart

![image-20220819104642718](C:\Users\13166\AppData\Roaming\Typora\typora-user-images\image-20220819104642718.png)

性能瓶颈：

- 缓存，（强缓存，ip地址缓存）
  - 设置强缓存

- 第一字节时间（TTFB）时间过久（客户端发起请求到等待接收服务器第一个字节数据的时间成为TTFB）
  - 网络原因，增加带宽，或使用CDN服务
  - 请求头携带了多余的用户信息（比如cookie），减少一些不必要的 Cookie 数据信息。使用http2的头部压缩对请求头进行压缩处理

**DCL（DOMContentLoaded，HTML加载解析完成的时间）**：

表示 HTML 文档加载完成事件, 初始 HTML 文档完全加载并解析之后触发，无需等待样式、图片、子 frame 结束

![image-20220819113154606](C:\Users\13166\AppData\Roaming\Typora\typora-user-images\image-20220819113154606.png)

performance.timing: domContentLoadedEventEnd - navigationStart

性能瓶颈：

由于是单页面应用因此只涉及到资源的下载和执行

- 资源过大或过多
  - 对css，js进行压缩
  - 路由懒加载，tree-shaking，减少资源加载的个数
  - 公共文件拆分，防止单个文件过大以及文件重复加载
- JavaScript执行时间过长
  - web worker执行一些不涉及页面渲染的任务
  - 减少不要的js依赖
- 网络原因
  - 使用http2
  - 使用cdn
  - 增加带宽
  - 对核心资源开启预解析，提前加载

**FCP(首屏内容绘制)**

首次绘制任何文本，图像，非空白 canvas 或 SVG 的时间点

![image-20220819162411030](C:\Users\13166\AppData\Roaming\Typora\typora-user-images\image-20220819162411030.png)

性能瓶颈

此阶段主要涉及js的加载与执行，优化手段同上

**LCP(最大内容绘制)**

页面上尺寸最大的元素绘制时间

![image-20220819162411030](C:\Users\13166\AppData\Roaming\Typora\typora-user-images\image-20220819162411030.png)

性能瓶颈

js，css的加载与执行，浏览器的渲染

- css
  - 减少css的嵌套，减少内联样式的使用，减少通用选择器后代选择器的使用
  - 开启GPU渲染
  - 减少回流重绘

- js
  - 减少对dom的访问
  - 使用requestanimation

**L(onload)**

页面所有资源加载完成事件

performance.timing：loadEventEnd - navigationStart

性能瓶颈

- 网络
  - 对图片资源进行压缩
- 资源数量

**TTI （Time To Internative）**

从页面开始到它的主要子资源加载到能够快速地响应用户输入的时间

当前页面页面完全加载且没有长任务在执行

**总阻塞时间 TBT（total blocking time ）** 

衡量从 FCP 到 TTI 之间主线程被阻塞时长的总和。