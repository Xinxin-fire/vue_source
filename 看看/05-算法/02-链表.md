## 01-链表

```js
function NodeList(val) {
    this.val = val; //val 为当前节点的值
    this.next = null; //next 指向下一个节点（当不需要比较值时，操作next即可）
}
```

#### LeetCode-160：找到两个单链表相交的起始节点。

题解1：双指针

1. 两个链表长度一样，第一次遍历结束后 pA 和 pB 都是 null，结束遍历
2. 两个链表长度不一样，两次遍历结束后 pA 和 pB 都是 null，结束遍历，假设两个链表有交点，则两个链表经过的路径分别为 a + c + b + c 和 b + c + a + c,所以会在最后c那段找到交点。
3. 时间复杂度：O(M + N)*O*(*M*+*N*), M, N 分别为两个链表的长度。
4. 空间复杂度：O(1)*O*(1)。

```js
var getIntersectionNode = function (headA, headB) {
    if (headA === null || headB === null) {
        return;
    }
    let A = headA, B = headB;
    while (A != B) {
        A = A === null ? headB : A.next;
        B = B === null ? headA : B.next;
    }
    return A;
}
```

题解2：暴力解法

通过将A的每个节点去B中寻找有没有相同的 

时间复杂度：O(M * N)*O*(*M*∗*N*), M, N 分别为两个链表的长度。

空间复杂度：O(1)*O*(1)

```js
var getIntersectionNode = function (headA, headB) {
    if (headA === null || headB === null) {
        return;
    }
    let A = headA;
    while (A) {
      let  B = headB;
        while(B) {
            if (A == B) {
                return A;
            }
            B = B.next
        }
        A = A.next;
    }
    return A
}
```

题解3：哈希表
先遍历一遍链表 A，用哈希表把每个节点都记录下来(注意要存节点引用而不是节点值)。

再去遍历链表 B，找到在哈希表中出现过的节点即为两个链表的交点。
时间复杂度：O(M + N)*O*(*M*+*N*), M, N 分别为两个链表的长度。

空间复杂度：O(N)*O*(*N*)，N 为链表 A 的长度。

```js
var getIntersectionNode = function (headA, headB) {
    if (headA === null || headB === null) {
        return;
    }
    let hashA = new Map();
    let A = headA;
    while (A) {
        hashA.set(A,1)
        A = A.next
    }
    while (B) {
        if (hashA.has(B)) {
            return B
        }
        B = B.next
    }
    return B
}
```

#### leetcode206:反转链表

题解1：迭代

在遍历链表时，将当前节点的next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用

时间复杂度：*O*(*n*)，其中 n*n* 是链表的长度。需要遍历链表一次。

空间复杂度：O(1)。

```
var reverseListNode = function (head) {
    let pre = null;//保存前一个节点
    let cur = head;
    while (cur) {
        let next = cur.next; //保存下一个节点
        cur.next = pre; //将前一个节点赋值给下一个节点
        pre = cur; //前一个节点变成了当前节点
        cur = next //当前节点变成下一个节点
    }
    return pre
}
```

题解2：递归

将链表分解为头部和剩余部分的反转，剩余部分接着分为头部和剩余部分，最后会拆分为只有两个节点的最小子问题的反转，

使用递归的三要素：

- 大问题可以拆分为两个小问题
- 子问题求解方式和大问题一样
- 存在最小子问题

```js
var reverseListNode = function (head) {
   if (head == null || head.next == null) {
       return
   }
    // newHead 头部之后经过反转的链表
   let newHead = reverseListNode(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

#### leetcode21:合并两个有序的链表

链表（next指针地址的问题）也是一个对象（深拷贝），当一个链表和一个变量内存索引相同时，其中一个里面的next值改变，另一个也会相应的改变。

方法1：迭代

```js
var mergeTwoLists = function(l1, l2) {
    const prehead = new ListNode(-1);
    let prev = prehead;
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            prev.next = l1;
            l1 = l1.next;
        } else {
            prev.next = l2;
            l2 = l2.next;
        }
        prev = prev.next;
    }
    prev.next = l1 === null ? l2 : l1;
    return prehead.next;
};
```

方法2：递归

可将问题拆解为两个问题（当前节点，以及剩余部分），并进行归并，

```js
var mergeList = function (l1, l2) {
   if (l1 === null) {
       return l2
   }  else if (l2 === null){
       return l1
   }  else if (l1.val < l2.val) {
       l1.next = mergeList(l1.next,l2);
       return l1
   }  else {
       l2.next = mergeList(l2.next,l1);
       return l2
   }     
}
```

#### leetcode83:删除排序链表中的重复元素

方法1：迭代

```js
var deleteDuplcates = function(head) {
    let cur  = head;
    while (cur && cur.next) {
        if (cur.val === cur.next.val) {
            cur.next = cur.next.next;
        } else {
            cur = cur.next;
        }
    }
    return head;
}
```

方法2：递归

可将问题拆解为两个部门：当前节点和下一个节点

```js
var deleteDuplicate = function(head) {
    if (head === null && head.next === null) {
        return head
    }
    head.next = deleteDuplicate(head.next);
    return head.val === head.next.val ? head.next : head;
}
```

#### leetcode19:删除链表的倒数第 n 个节点

方法1：快慢指针

先将快指针向前移动n个节点，再将快慢指针同时向前移动，当快指针移动到链表的尾部时，此时慢指针正停留在倒数第n个节点上

```js
var removeNthFromEnd = function(head, n) {
    let fast = head;
    while(n-- > 0) {
        fast = fast.next;
    }
    if (fast == null) return head.next;
    let slow = head;
    while(fast.next) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;
    return head
};
```

方法2：暴力解法

先将链表遍历一遍获取数组的长度，然后通过length-n要获取删除的节点索引，通过哑结点的方式，获取到头节点的前一个节点，这样通过cur.next = cur.next.next,也能删除头结点了

```js
var removeNthFromEnd = function(head, n) {
     // 获取链表长度
    let h = head, length = 0;
    while (h) {
        h = h.next;
        length ++;
    }
    // 要删除的节点索引
    let index = length -n,currentIndex = 0;
    let  cur = new ListNode(-1, head); 
    head = cur;
    while (cur.next) {
        if (index === currentIndex) {
            cur.next = cur.next.next
            return head.next
        } else {
            cur = cur.next;
            currentIndex++;
        } 
    }
    return head.next
};
```

#### leetcode24:交换链表中的相邻结点

方法1：双指针（交换链表的值，但是节点未动），将快指针与慢指针的值进行交换，并向后走两步（注意边界情况）

```js
var swapPairs = function(head) {
    if (head===null) return head;
    let fast = head.next, slow = head;
    while(fast) {
        let pre = fast.val;
        fast.val = slow.val;
        slow.val = pre;
        if (fast.next) {
            fast= fast.next.next;
            slow = slow.next.next;
        } else {
            return head
        }
    }
    return head;
};
```

方法2：交换链表的节点，定义一个哑结点temp，将temp>l1>l2转为temp>l2>l1的代码为

```js
let l1 = temp.next, l2 = temp.next.next;
temp.next = l2;
l1.next = l2.next;
l2.next = l1;
```

```js
var swapPairs = function(head) {
    let pre = new ListNode(-1);
    pre.next = head;
    let cur = pre
    while(cur.next && cur.next.next) {
        let node1 = cur.next;
        let node2 = cur.next.next;
        cur.next = node2;
        node1.next = node2.next
        node2.next = node1;
        cur = node1;
    }
    return pre.next
};
```

方法3：递归

将问题可分解为大问题和小问题，小问题为交换链表的头两个节点即剩下的节点

```js
var swapPairs = function(head) {
  if (head === null || head.next === null) {
      return head;
  }
    let newHead = head.next;
    head.next = swapPairs(newHead.next);//head变为第二个节点并指向后面
    newHead.next = head;//newHead变为头节点
    return newHead;
}
```

## leetcode445: 链表求和

通过将链条压入栈的方式，对链表进行求和

将每个数从个数开始相加，没有的补0，设置一个进位数curry，每次的总数等于，两个数和curry的总和，当前位的数为sum%10,进位数curry为parseInt(sum/10)；

```js
var addTwoNumbers = function(l1, l2) {
  let stack1 = [];
  let stack2 = [];
  while(l1) {
     stack1.push(l1.val);
     l1 = l1.next
  }
  while(l2) {
     stack2.push(l2.val);
     l2 = l2.next
  }
  let curry = 0;
  let ansList  = null;
  while(stack1.length || stack2.length || curry !== 0) {
    let val1 = stack1.length ? stack1.pop() : 0;
    let val2 = stack2.length ? stack2.pop() : 0;
    let sum = val1 + val2 + curry;
    curry = parseInt(sum/10);
    val = sum%10;
    const curNode = new ListNode(val);
    curNode.next = ansList ;
    ansList = curNode;
  }
  return ansList
}
```

#### leetcode234: 回文链表

1.通过将链表转换为数组进行判断

```js
var isPalindrome = function(head) {
    let arr = [];
    while (head) {
        arr.push(head.val);
        head = head.next;
    }
    for (let i = 0, j = arr.length - 1; i < j ; i++, j-- ) {
        if (arr[i] !== arr[j]) {
            return false;
        }
    }
    return true;
};
```

2.快慢指针，快指针走两步，慢指针走一步，当快指针走到末尾时，慢指针刚好走到中间，此时可将中间的后半部分节点反转与前半部分进行比较，来判断是否为回文字符串。

```js
var reverseList = function (head) {
  if (head === null || head.next === null) {
      return head;
  }
    let pre = null,cur = head;
    while (cur) {
        let Next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = Next;
   }
    return pre
}
var halfList = function (head) {
  let fast = head, slow = head;
    while (fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow.next  
}
var isPalindrome = function(head) {
    let half = halfList(head);
    let reverseHalf = reverseList(half);
    let p1 = head,p2 = reverseHalf;
    while (p2) {
        if (p1.val !== p2.val) {
            return false
        }
        p1 = p1.next;
        p2 = p2.next;
    }
    return true
};
```

3.递归

在全局中定义一个头节点，再通过递归到链表的末尾与头节点进行比较，从而判断是否为回文链表

```
let frontPointer;

const recursivelyCheck = (currentNode) => {
    if (currentNode !== null) {
        if (!recursivelyCheck(currentNode.next)) {
            return false;
        }
        if (currentNode.val !== frontPointer.val) {
            return false;
        }
        frontPointer = frontPointer.next;
    }
    return true;
}

var isPalindrome = function(head) {
    frontPointer = head;
    return recursivelyCheck(head);
};
```

#### leetcode328: 奇偶链表

```js
var oddEvenList = function(head) {
    if (head === null) {
        return head;
    }
    let evenHead = head.next;
    let odd = head, even = evenHead;
    while (even !== null && even.next !== null) {
        odd.next = even.next;
        odd = odd.next;
        even.next = odd.next;
        even = even.next;
    }
    odd.next = evenHead;
    return head;
};
```

