#### 一、白屏优化

物流平台这个项目上线后，发现白屏时间过长，用户体验很差，

于是我通过chrome的lighthouse和performance工具对项目性能进行了分析，发现FCP指标达到了5.9s

我主要从网络层面和渲染层面对项目进行了优化，首先是网络层面，我通过**webpack-bundle-analyzer**对项目进行了分析，移除了一些冗余文件如：mock.js,video.js,对echarts和elementui进行了按需引入，

发现主文件app.js过大，有2M多，于是对文件进行了拆分，通过splitchunks将公共组件，node_modules包进行了提取,

然后对js,css，图片进行了压缩，图片主要是通过网站在线压缩，压缩比例大概在百分之60-70%，js（tenser），css（ **optimize-css-assets-webpack-plugin**）除了对代码压缩外，还进行了gzip进行了压缩，开启了http2，减少了资源请求的等待时间，通过preload对核心文件element-ui和app.js进行了预加载

然后是渲染层面

渲染层面，这个项目中主要是首页有一个gif图，这个图比较大，而且浏览器渲染的耗时时间也比较长，我通过两张图片拼接，用动画的方式进行了替换，替换后图片大小有1M降到到了100kb，并且使用了will-change开启了GPU渲染，此外还有给图片初始化宽高减少重绘回流，减少对dom的访问等

#### 二、打包构建优化

搅拌站管理系统这个项目涉及到了一百多个页面十几个模块，代码量很大，但是打包构建太慢严重影响了开发效率，

我主要从五个方面进行了打包构建的优化，首先的多核，利用cpu和多核平行运行的原理进行打包构建，主要通过thread-loader进行配置，还可以配置tenserplugin对js代码进行平行压缩

第二个是缓存，可以大大减少第二打包构建的速度，主要是通过cache-loder，还有配置babel的**cacheDirectory**

第三个是排除通过include、exclude、externals避免不要的打包

第四个是通过dll将不常变动的文件提前打包，然后通过以动态链接库的形式引入，避免重复打包

第五个是合理配置resolve.alias,resolve.extensions减少文件的查找时间

#### 三、大文件上传

物流平台这个项目，当添加一个新租户时需要导入大量的历史运单数据，数据量太大容易导入失败，然后需要重新从头开始导入，因此增加了断点续传这个功能

断点续传主要是通过将文件转换成二进制流的形式，利用流可以切割的方式，通过slice方法将文件切割成固定的大小5M，通过web worker和md5计算上传文件的hash，上传时传递给服务器文件的hash值和当前文件的索引，当所有分片上传完成时，再向服务器发送一个合并的请求，服务器根据文件的hash值和对应的索引将文件进行合并

如果文件上传失败，第二次进行上传时，据文件的hash值和对应的索引，服务器会判断是否已经保存了该文件分片，从而实现文件断点续传的功能

#### 四、菜单权限和按钮权限的设计

菜单权限主要是通过动态路由的方式实现的，将路由分为同步路由和异步路由，根据后端返回的接口将id匹配成功的异步路由和同步路由进行组装，组装成完整的同步路由，

按钮的权限设计是通过自定义指令实现的，将根据后端接口获取对应路由的按钮权限，给对应按钮添加上对应的指令，实现按钮的显示和隐藏

#### 五、虚拟列表的实现的实现

搅拌站管理系统有个生产页面，需要实时看到当前生产的数据和排队的车辆，不能对表格使用分页，但是数据量多的时候页面卡顿严重，因此采用了虚拟列表的对页面进行了优化

主要通过**vue-virtual-scroll-list**这个插件实现的，它的原理就是通过计算表格区域需要展示的数据条数，将数据进行截取，监听表格的滚动事件，在表格滚动时，将要展示的数据进行替换，并动态更新当前区域距离顶部区域的高度来模拟表格的滚动

#### 六、智慧大屏的实现

智慧大屏主要用于展示搅拌站的数据统计，主要通过echarts实现，
这里面的难点，一个是页面元素众多，需要写大量的样式，布局等，一个各种echarts图表，配置项较多较复杂

还有屏幕自适应的实现，主要是通过transform：scale来实现的，初始化设计稿的宽高比，获取当前页面的可视宽高，根据设计稿的宽高与当前页面的可视宽高的比例来进行设置scale的大小，从而实现页面的最佳显示效果

#### 七、车辆轨迹的实现

这个车辆轨迹回放，是用来监控车辆的运动轨迹，可以随时查看某个叉车在厂区附近的运行路线，主要是通过高德地图来实现的，

最开始我是通过高德地图原生的轨迹回放功能实现的，他是通过**AMap.Polyline**设置一个轨迹路线，通过**marker.moveAlong**让图标沿着轨迹开始运动，然后监听**marker的moving**事件，在回调函数中不断设置maker已经走过的路径，marker.on('moving', function (e) {
        passedPolyline.setPath(e.passedPath);
    });
这个实现主要的问题是没有办法设置滚动条的拖动功能，因为你根据滚动条的位置设置了标记路过的路径，但是没法设置marker的moving的状态，他还是依旧会从上此的位置接着往下运动，而且播放动画也不是很流畅

最后我通过高德地图的ui框架**PathSimplifier**，开启一个巡航器来实现的，实现之后的动画也更流畅，
期间还解决了一个棘手的bug，就是他是通过canvas来渲染的，每次查询都会新增一个canvas，即使销毁巡航器他渲染的canvas也还在dom中，查询次数多了，会出现层爆炸的情况就是会出现好多地图层，且有多个图标在跑动，我通过每次查询销毁上一次渲染的dom的方式解决了这个bug

#### 八、Vue

##### vue响应式原理

vue通过递归的使用Object.defineProperty对对象的属性进行了检测，给每个对象初始化了Dep属性，当访问该对象时，触发getter函数，getter函数中通过Dep.deppend收集当前的watcher，当修改对象属性的值时，触发setter函数，setter函数通过Dep.notify通知dep中收集的watcher进行，

对于数组是重写了数组上的七个方法，数组的依赖收集和派发更新都是通过对象数据的_\_ob__属性来完成的

模板编译原理

通过正则匹配的方式对template模块进行解析，生成一个ast语法树，将ast语法树拼接成一个字符串，字符串中有_c(), _s(),\_v()等方法，这些方法被挂载在Vue的原型上，通过new Function with（this）的方式生成一个render函数， with（this）是为了让函数中的变量指向new Function生成的实例，执行render函数会调用\_c(), _s(),\_v()等方法生成虚拟节点

异步更新原理

同步往队列里面添加回调函数  采用优雅降级 promise=>mutationObserver=>setImmediate=>settimeout的异步方式去循环执行队列里面的函数

computed原理

watcher原理

$set原理

组件渲染原理

#### 九、Webpack

##### webpack打包过程

首先是初始化参数，从配置文件和shell语句中读取并合并，得出最终的参数，

然后是开始编译，通过得到的参数初始化compiler对象，加载所有配置的插件，执行对象的run方法开始编译

确定入口，根据配置中的entry找到所有入口文件

完成编译 从入口开始，调用所有配置的loader将入口所依赖的模块进行解析，最终得到解析后的文件内容和模块之间的依赖关系

输出文件， 根据模块之间的依赖关系组成一个个包含多个模块的chunk，再把每个chunk转换成一个单独的文件加入到输出列表

输出完成， 在确定好输出内容后根据配置确定输出的路径和文件名，把文件内容写到文件系统中

##### 热更新原理

开启热更新后webpack-dev-server会开启两个服务，一个express服务，用于初次访问页面时提供静态资源，一个Soket的服务，它是一个长链接，可以实现服务器的推送，当服务器监听到对应模块发生变化时，会生成一个.json文件和一个.js文件，并通过长链接的形式发送给浏览器，浏览器拿到这两个文件后会加载这两个文件，对修改的模块进行更新

#### 十、自我介绍等

面试官,你好,我叫鑫辰大海,是一个三年经验的前端工程师,我的技术栈是vue,对vue的源码和底层设计有一定的了解,掌握的ui框架有element-ui,echarts等,有后台管理系统,小程序等方面的项目经验,对前端性能优化和屏幕分辨率的适配有一定的研究，平常喜欢看一些大佬的技术博客和一些学习视频，比如修言老师的掘金小册，王红元老师的webpack视频等来提升自己,我的自我介绍完了,谢谢面试官

#### 十一、想问的问题

1.冲大厂的机会大吗

2.我目前可以说自己是三年经验吗

3.技术改进的地方及方向

4.跳槽预计的薪资可以达到多少



