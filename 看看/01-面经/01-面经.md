### 00-面经

#### 将对象转为数组

```js
var ObjectToArray = function(obj) {
    return Object.values(obj)
}
var ObjectToArray = function(obj) {
    let arr = [];
    for (let key in obj) {
        //排除原型上的属性
        if (obj.hasOwnProperty(key)){
            arr.push(obj[key]);
        }
    }
    return arr
}
//注意，因为Symbol具有私有性，无法通过循环遍历得到，故这两种方式都不会返回Symbol属性的值
```

#### 将一个整数翻转

```js
function reverseNum(num) {
    return Number(String(num).split("").reverse().join(""))
}

function reverseNum(num) {
    if (num == 0) {
        return 0
    }
    let res = 0;
    while (num !== 0) {
        res = res * 10 + num % 10;
        num = parseInt(num/10)
    }
    if (res < Math.pow(-2, 31) || res > Math.pow(2, 31) - 1) {
        return 0;
    }
    return res;
}
```

#### JS的特点

1. JavaScript是一种解释性执行的脚本语言，不要像Java那样需要先编译，而且在程序运行过程中被逐行解释（变量提升，和函数提升只是在js运行前，进行预浏览时，将代码提前了，并没有执行和编译）
2. JavaScript是一种基于对象的语言，JavaScript自身提供了许多内置对象，如Object、Function、Date、Promise、（BOM、DOM）等等，Javascript大部分功能都是来自对这些对象方法的调用
3. JavaScript是一种简单弱类型语言，其变量类型是采用弱类型，并未使用严格的数据类型。
4. javascript是一种安全性的语言，javascript由浏览器运行，它既不允许访问客户端的文件，也不允许在服务器端打开文件和保存信息。它只允许客户查看信息和实现同客户的交互。
5. javascript是一种跨平台性脚本语言，JavaScript依赖于浏览器本身，与操作环境无关，只要计算机能运行浏览器，并支持JavaScript的浏览器，就可正确执行。
6. javascript是一种动态性语言。JavaScript是一种采用事件驱动的脚本语言，它不需要经过Web服务器就可以对用户的输入，鼠标单击等事件做出响应。

#### JS将一个M进制的数转换为N进制

M.tostring(N),或者parseInt(M,N)

#### indexOf与instanceof

- indexOf用来检索字符串中指定内容在字符串中的索引值
- 参数1,要检索的内容
- 参数2,从哪里开始检索,如果未检索到则返回-1,与search()类似,不同的是search的检索内容可以使用正则表达式
- instanceof
- 语法: A instanceof B A为一个实例对象,B为一个函数,如果B的显式原型在A的原型链上则返回true

#### 将对象转为数组

```
var arr = []
for(let i in obj ){
  let o = {}
  o[i] = obj[i]
  arr.push(o)
}
for...in 语句用于遍历数组或者对象的属性
```

#### JS判断一个变量是否为整数

```
1.  num%1 ===0 && typeof num === 'number'
2.  Math.round(num) === num && typeof num === 'number'
3.  Number.isInteger(num)
```

#### visibility=hidden ,opacity=0, display=none的区别

- visibility=hidden，元素隐藏，但是占据空间（不会改变页面布局），不会触发该元素已经绑定的事件
- opacity=0，元素透明度为零，占据空间（不会改变页面布局），且会触发该元素已经绑定的事件

#### var a ,b = null ,a ===b,和a ==b的结果是什么？为什么是这样？

- 结果为true，true
- null表示变量未指向任何对象，为JS的基本类型之一。

#### CSS的选择器

- 实现div里面所有的p元素的背景颜色为黄色

- div p {background-color: #ff0;}

- 实现div后面所有的p元素的背景颜色为黄色

- div~p {background-color: #ff0;}


#### CSS实现三角形 

```
div {
      width: 0;
      height: 0;
      border-top: 50px solid red;
      border-right: 50px solid transparent;
      border-left: 50px solid transparent;
    }
```

#### let、const实现块级作用域的原理

- JS是一门解释执行的语言，JS引擎从上到下解析执行代码，需要经历编译和执行两个阶段，在编译阶段将各执行上下文按照对应关系压入执行上下文栈中；
- 当查找变量时，会先从当前上下文的变量中查找，如果没有找到，就会从父级的执行上下文的变量中查找，一直找到全局上下文的变量对象；
- let、const定义的变量相当于在某一个执行上下文中，只有访问的变量在当前执行上下文中在能访问的到，且let、count存在暂存性死区，当前作用域内，在let、const声明之前访问这些变量会报错。

#### 为什么vue避免直接操作dom

- 假如一次操作中有十次更新DOM的操作，直接操作DOM的情况下浏览器会执行10次构建DOM树的流程，浪费了大量的性能，容易造成页面卡顿影响用户体验
- vue通过虚拟DOM，在10次更新DOM的动作时，不会立即操作DOM，而是将这10次更新的diff内容保存到本地的JS对象中，等更新完成后，再将最终的JS对象映射成真实的DOM交由浏览器进行绘制。
- 用 `JS` 对象模拟 `DOM` 节点的好处是，页面的更新可以先全部反映在 `JS` 对象(虚拟 `DOM` )上，操作内存中的 `JS` 对象的速度显然要更快。

#### js是如何基于对象的

- 基于对象是先有一个具体的对象，然后再这个对象的基础上创建新的对象
- 面向对象是先有一个抽象对象的描述，然后以此为蓝本构建具体的对象
- js中提供了许多内置对象，以及这些对象的方法和对象原型上的方法，通过这些方法可以实现js大部分的功能

#### 隐藏元素的几种方法

1. **visibility: hidden**; 这个属性只是简单的隐藏某个元素，但是元素**占用的空间依然存在，不可响应事件**，发生重绘不发生回流
2. **transform: scale(0);** 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留，**占据空间，不可响应事件**
3. **opacity: 0**; CSS3属性，设置0可以使一个元素完全透明，**占据空间也可响应事件**，发生重绘不发生回流
4. **position**；**占据空间也可响应事件**
5. **display: none**; 元素会变得不可见，**不占用文档的空间，也不会响应事件**
6. **z-index**；不占据空间，无法点击

#### 说说MD5

- MD5是通过一种密码散列函数（hash算法），来产生一个128位的散列值，用来确保信息传输的完整。
- 特点：
  - 不可逆，不能依据md5值反推原来的数据
  - 高度的离散型 原信息有一点点的变化都会导致MD5产生巨大差异
  - 压缩性 MD5的长度是固定的
  - 弱碰撞性 两个数据的MD5值相同的概率非常低
- 用途：
  - 密码加密存储 ，用户设置密码时服务器只需记录这个密码的MD5值
  - 数字签名  在发布程序时公开MD5码，别人只要在下载这个程序的时候做一次MD5对比就能知道，程序是否被串改
  - 文件完整性验证  同上
  - 文件上传  对比上传的时候MD5码是否存在，存在就可以直接上传了

#### CSS盒模型

- 盒模型分为：

  - W3C标准盒模型（ box-sizing:content-box;）：属性width,height只包含内容content，不包含border和padding
  - IE盒模型（ box-sizing:border-box;）：width = border + padding + 内容的宽度，height = border + padding + 内容的高度

#### BFC（格式化上下文）是什么

- 具有BFC特性的元素可以看作是隔离了的独立容器，其内部有一套渲染规则，容器里面的元素不会在布局上影响到外面的元素
- **BFC的触发**
  - body根元素
  - 浮动元素：float除none以外的值
  - 绝对定位元素：position（absolute、fixed）
  - display为inline-block、table-cells、flex
  - overflow 除了 visible 以外的值 (hidden、auto、scroll)
- BFC的特性
  - 同一个BFC的两个相邻Box的margin会发生重叠
    - bfc导致的属于同一个bfc中的子元素的margin重叠(Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠)
      我们可以在div外面包裹一层容器，并触发该容器生成一个BFC。那么两个div便不属于同一个BFC，就不会发生margin重叠了。
  - 可以包含浮动元素
    - 块级子元素浮动，如果块级父元素没有设置高度，其会有高度塌陷的情况发生，
    - 原因：子元素浮动后，开启了BFC，父元素不会被子元素撑开。
    - 计算BFC的高度时，浮动元素也参与计算。所以只要将父容器设置为bfc
      就可以把子元素包含进去
  - 阻止元素被浮动元素覆盖

#### js的数据类型

- 基本数据类型：Number、boolean、String、Null、Undefined、Symbol、BigInt
- 引用数据类型：Object（包含Array、Function、Date、Error、RegExp、Blob）

#### 判断数据类型的方法

- typeof 用来判断基本数据类型（null除外）

- Object.prototype.toString.call()，可以用来判断所有的数据类型，返回值如：‘[object Object]’

- instanceof ，用来判断引用数据类型（不能排除Object类型）, A instanceof B === true 表示A为B的实例

  - ```
    [1,2,3] instanceof Array   //true
    [1,2,3] instanceof Object  //true
    ```

- constructor，可以用来判断基础类型和引用类型，不能用来判断null和undefined(注意constructor被修改)

  - ```javascript
    var str = 'hello';
    alert(str.constructor == String);//true
    var bool = true;
    alert(bool.constructor == Boolean);//true
    ```

- Array.isArray()判断数组
- ===，判断undefined、null、boolean值等

#### 作用域及作用域链

- 作用域
  - 是在代码运行时，某些特定部分中变量，函数和对象的可访问性
  - 作用域就是一个独立的区域，让变量不会外泄、暴露出去**，**不同作用域下同名变量不会有冲突
  - js中作用域分为全局作用域、函数作用域和块级作用域（let、const定义）
- 作用域链
  - 作用域也可以根据代码层次分层，在里面的子作用域可以访问到外面的父作用域
  - 一个变量会现在当前作用域中查找，如果没有找到，则顺着作用域链向创建其作用域里查找，直到找到或查找到全局作用域为止，如果全局作用域也没有声明则报错。
- 作用域链原理
  - 函数有一个内部属性scope，当函数创建的时候就会保存所有父变量的对象到其中
  - 当执行该函数时，进入函数上下文，将活动对象添加到作用域链的顶端

#### Promise

- Promise规范
  - 一个Promise有且只有一个状态，pending状态时可能转换为fulfilled或rejected状态，fulfilled或rejected状态不能改变为其他任何状态，必须有一个value/reason且不可改变
  - promise必须提供一个then方法，用来获取当前或最终的 value 或 reason，then方法接受两个参数，onFulfilled 和 onRejected 都是可选参数，如果 onFulfilled、onRejected 不是函数，它会被忽略。
  - 如果 onFulfilled/onRejected 是一个函数：
    -  它一定是在 promise 是 fulfilled /rejected状态后调用，并且接受一个参数 value/reason
    -  它最多被调用一次
  - promise 的 `then` 可以链式调用多次,then 方法一定返回一个 promise
- Promise执行栈里不手动掉用resolve，还有什么方法可以调用
- Promise，then为什么要返回一个新对象
  - 方便进行链式调用，如果返回的不是新的promise对象，那么同一个promise对象的属性和方法会被覆盖

#### ES6新特性

1. const、let（块级作用域，不能重复声明、存在暂存性死区）
2. 模板字符串
3. 箭头函数（不需要function关键字来创建函数，省略return关键字，没有arguments，继承当前上下文中的this），当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return；
   - 箭头函数的特点：
     - 自身没有this，会捕获其所在上下文的this作为自己的this
     - 没有arguments，可以通过...args代替
     - 没有原型
     - 不能作为构造函数
     - 箭头函数不能当做Generator函数,不能使用yield关键字
4. 可以设置函数的参数默认值
5. 解构赋值
   - ES6变量的解构赋值本质上是“模式匹配”,只要等号两边的模式相同，左边的变量就会被赋予匹配的右边的值，如果匹配不成功变量的值就等于undefined
6. 扩展运算符
   - 字符串
   - 数组
   - 对象
   - arguments
7. 对象和数组的解构
8. for...in,for...of
9. class，类
10. Promise
11. 对象属性/方法简写（对象的属性和值相同时，省略属性名）
12. Array.prototype.includes
13. import导入导出
    - CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
      CommonJS 模块是运行时加载，ES6 模块是编译时输出接口
14. Symbol
15. set、map
16. generator

#### 父子组件通信

父给子传的值为浅拷贝，当给子组件传一个数组，若子组件修改了这个数组，那么父组件的数据也会跟着改变

#### JS引擎解析机制

- JS是解释性语言，不会进行预编译，而是边编译边执行
- 在源代码进入JS引擎之后，会顺序读取代码，按照变量声明、函数执行等不同规则，分配到堆或栈内，JS引擎会将代码分成一个个执行上下文，依次进入执行栈中，
- JS是单线程的，执行栈内的代码会遵循先进后出的原则，只有栈顶的函数会被处理，处理完后弹出栈，后面的进入栈顶，再被执行。
- 在同步代码的情况下，JS引擎会按照代码书写的逻辑，依次调用函数，在任意时间点，有且只能有一个函数被执行。外层函数必须等到内层函数处理完毕有返回值之后才能继续执行。
- 如果碰到异步任务，JS引擎会将代码交给浏览器的Web API模块进行处理，而Web API模块为多线程可以同时处理多个异步任务，这些异步任务拿到结果后会带着回调函数被推倒回调队列（先进先出），回调函数会按照进队列的顺序被执行。
- 其中异步任务还分为宏任务（setTimeout、setInterval）和微任务（Promise），当主线程执行完毕会先执行微任务，微任务执行完再执行宏任务。
- Event Loop会不停的检查主线程调用栈和回调队列，当主线程空闲时就把回调队列里的第一个任务推入主线程执行。

#### promise如何解决异步回调地狱的问题

- promise有三种状态，可以很好的对异步获取的成功或者失败的结果进行处理
- promise可以通过then方法来获取异步调用的结果，且then方法返回一个新的promise对象可以接着进行调用then方法，这样就形成了then的链式调用，优雅的解决了异步回调地狱的问题

####   MVVM与MVC的区别

- MVC通过Controller连接视图层和数据层，MVVM通过ViewModel连接视图层和数据层
- MVC都是单向联系，视图层传送指令到Controller再改变Model的状态
- MVVM中的ViewModel与视图层和数据层都是双向联系，VM能够自动监听到数据的变化并自动渲染页面，也能够监听页面的变化并自动更新数据层

#### 前端安全

XSS/CSS（跨站脚本攻击）

- 攻击者在目标网站植入恶意脚本（js/html）,用来获取用户敏感信息，修改web页面以欺骗用户等
- 防范：对用户输入内容和服务端返回内容进行过滤和转译，重要内容加密传输，对于URL携带参数谨慎使用

CSRF / XSRF（跨站请求伪造）

- 攻击者盗用了你的身份，以你的名义进行恶意请求。
- 防范：token校验、验证码校验、Referer 验证

ClickJacking（点击劫持）

- 攻击者利用透明 iframe 覆盖原网页诱导用户进行某些操作达成目的
- 防范：判断当前网页是否被 iframe 嵌套
- 在HTTP投中加入 X-FRAME-OPTIONS 属性，此属性控制页面是否可被嵌入 iframe 

不安全的第三方依赖

- 尽量减少第三方依赖，选用相对成熟的依赖包。
- 使用自动化工具检查这些第三方代码有没有安全问题，比如NSP(Node Security Platform)，Snyk等等。

本地存储数据泄露

- 不在本地存储重要数据

#### 回流重绘

回流:当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变
- 元素内容变化（文字数量或图片大小等等）
- 元素字体大小变化
- 添加或者删除**可见**的`DOM`元素
- 激活`CSS`伪类（例如：`:hover`）
- 查询某些属性或调用某些方法

重绘:当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

如何避免

- 避免使用`table`布局。
- 尽可能在`DOM`树的最末端改变`class`。
- 避免设置多层内联样式。
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上。
- 避免使用`CSS`表达式（例如：`calc()`）。
- 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
- 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

#### Iterator

Iterator为各种数据结构（Array、Set、Map、String、arguments、NodeList、TypeArray）提供一个统一简单的访问接口，使得数据结构的成员能够按照某种次序排列，完成遍历操作，还为for...of操作提供了方法

Iterator 的遍历过程

- 创建一个指针对象指向当前数据结构的起始位置，调用指针对象的next方法指向数据结构的第一个成员
- 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员。
- 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置。

使用场景

- for...of
- 解构赋值
- 扩展运算符
- yield

#### 解构赋值的原理

针对可迭代对象的Iterator接口，通过遍历器按顺序获取对应的值进行赋值。

#### 垃圾回收机制

垃圾回收是一种自动的内存管理机制，当一个对象不再被引用时就成了垃圾，这时就需要将其释放，以让出内存。

- **标记清除法**：垃圾收集器会在内存中给所有变量都加上一个标记0，并从根元素对象开始遍历，若有引用到则标记为1，遍历完成后，会将标记为0的对象进行销毁并回收，然后等待下一次的标记清除
  - 优缺点：实现比较简单，但回收的剩余对象内存位置是不变的，会导致空闲内存空间是不连续的，出现 内存碎片，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题
- **引用计数法**：此算法会跟踪每一个对象的引用次数，当某个对象的引用次数为0时就会被销毁并回收。
  - 优缺点：在对象引用次数变为0的那一刻就会立即被清除，而标记清除则是每隔一段时间进行清除；但是首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题
- **分代回收**——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。
- **增量回收**——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。
- **空闲时间收集**——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。

以下四种情况会造成内存的泄漏：

- **意外的全局变量：**由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
- **被遗忘的计时器或回调函数：**设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
- **脱离 DOM 的引用：**获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。
- **闭包：**不合理的使用闭包，从而导致某些变量一直被留在内存当中。

#### Set对象

Set对象是值的集合，它允许你存储任何类型的唯一值，初始化Set对象时需要传入一个可迭代的对象（数组、字符串、set、map、arguments等），可看做是去过重的数组

#### Map对象

Map对象保存键值对，并且能够记住键的原始插入位置，任何值都可以作为一个键或一个值，在Map对象的键中NaN与NaN是相等的，其他的判等与全等一致

Map与Object的区别

- object包含原型链上面的键，而Map只包含显式插入的键
- object的键必须是String或者Symbol，而Map的键可以是任意值
- Object的键是无序的（在只有字符串键的对象上进行迭代将按插入顺序产生键），Map的键是有序的
- Map上键的个数可以通过size获取，Object上键的个数只能手动计算
- `Map` 是 [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) 的，所以可以直接被迭代，迭代一个`Object`需要以某种方式获取它的键然后才能迭（for...in、Object.keys()、Objec.values()、Object.getOwnPropertyNames(obj)、Reflect.ownKeys(obj)）
- Object在频繁添加和删除键值对的场景下未作出优化，Map在频繁增删键值对的场景下表现更好

具体API操作请见Set-Map.js文件

#### 函数防抖

在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

应用场景：window触发resize

#### 函数节流

规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

鼠标不断点击触发，search搜索联想，下拉加载更多。