## 05-JavaScript-进阶

#### 1.原型

1.prototype的定义

- 给其它对象提供共享属性的对象

2.一个对象如何为另一个对象提供属性访问呢

- 所有的object都有一个隐式引用，它被称之为这个对象的prototype原型

#### 2.函数对象和普通对象

所有的Function的实例都是函数对象，即函数对象的构造函数为Function；其它的均为普通对象。

_\_proto\_\_和constructor是对象独有的,但是prototype是函数对象独有的

#### 3.对象的prototype对象的访问

- 通过 `Object.getPrototypeOf(obj)` 间接访问指定对象的 `prototype` 对象
- 通过 `Object.setPrototypeOf(obj, anotherObj)` 间接设置指定对象的 `prototype` 对象

#### 4.原型链

```javascript
function A () {}
let b = new A()
b.__proto__ === A.prototype //true
b.constructor === b.__proto__.constructor === A.prototype.constructor === A //true
```

- 如上，b为A的实例对象，所以b的隐式原型指向A的显式原型（**实例对象的隐式原型指向其构造函数的显式原型**）
- A为构造函数，b是被A构造出来的，所以b的constructor等于函数A，且b的隐式原型的constructor也等于A，由于b的隐式原型等于A的显示原型，则A的原型的constructor也等于A

```javascript
A.prototype.__proto__ === Object.prototype //true
Object.prototype.__proto__ === null //true
Object.prototype.constructor === Object // true
```

- 由于A.prototype也是一个对象，所以A.prototype是Object的实例对象

```javascript
Function.constructor === Function // true
Function.prototype === Function.__proto__ //true
Function.prototype === Object.__proto__ //true
Function.prototype === A.__proto__ //true
```

- **Function是所有函数对象的构造函数（包括Object和其本身），所以所有函数的隐式原型都指向Function的显式原型**

```javascript
Function.prototype.__proto__ === Object.prototype
Object.__proto__.__proto__.__proto__ === null //true
```

- **除了Object本身，其他函数对象的prototype都是Object的实例对象（包括Function.prototype）** 

#### 5.闭包

闭包就是能够读取其他函数内部变量的函数，在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的子函数"

闭包有两个常用的用途；

- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
- 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

弊端：内存泄漏

#### 6. 对作用域、作用域链的理解

##### 1）全局作用域和函数作用域

（1）全局作用域

- 最外层函数和最外层函数外面定义的变量拥有全局作用域
- 所有未定义直接赋值的变量自动声明为全局作用域
- 所有window对象的属性拥有全局作用域
- 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。

（2）函数作用域

- 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到
- 作用域是分层的，内层作用域可以访问外层作用域，反之不行

##### 2）块级作用域

- 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）
- let和const声明的变量不会有变量提升，也不可以重复声明
- 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。

**作用域链：**

在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。

**词法作用域（静态作用域）**

JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了

#### 7. 对执行上下文的理解

##### 1. 执行上下文类型

**（1）全局执行上下文**

任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。

**（2）函数执行上下文**

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。

##### 2. 执行上下文栈

- JavaScript引擎使用执行上下文栈来管理执行上下文
- 当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。

**简单来说执行上下文就是指：**

在执行JS全局代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。

在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。

- 全局上下文：变量定义，函数声明
- 函数上下文：变量定义，函数声明，`this`，`arguments`

#### 8. 对this对象的理解

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

- 第一种是**函数调用模式**，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
- 第二种是**方法调用模式**，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
- 第三种是**构造器调用模式**，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
- 第四种是 **apply 、 call 和 bind 调用模式**，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

#### 9. 异步编程的实现方式？

JavaScript中的异步机制可以分为以下几种：

- **回调函数** 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。
- **Promise** 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。
- **generator** 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。
- **async 函数** 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。

####  10.对Promise的理解

Promise 对象是异步编程的一种解决方案。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。

状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。

**注意：**在构造 `Promise` 的时候，构造函数内部的代码是立即执行的

#### 11. 对async/await 的理解

async/await其实是`Generator` 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。

#### 12. await 到底在等啥？

await 表达式的运算结果取决于它等的是什么。

- 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。
- 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。

这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行

#### 13. async/await对比Promise的优势

- 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担
- Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅
- 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余
- 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。

#### 14. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？

1. 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
2. 嵌套函数一多，就很难处理错误

#### 15.JS的继承

什么是继承呢？继承是指子类继承父类的属性和方法，便于代码的复用

- 原型继承

```
function Parent() {

}
function Child() {

}
child.prototype = new Parent()
//使子类的原型等于父类的实例,此时child.prototype.constructor 为Parent函数对象
```

- 原型继承的特点:

- - 与其他后台语言不同,其他后台语言一般是拷贝继承,把父类的属性和方法拷贝一份到子类中供子类使用,而JS是把父类的原型放到子类实例的原型链上,是基于__prototype__原型链查找机制完成
  - 子类可以重写父类的方法并且会导致父类的其他实例也受影响
  - 父类的私有或公有属性和方法,最后都会变成子类中公有的属性和方法
  - 不能传参,不能实现多继承

- call继承

  ```
  function Parent(name,age) {
  
  }
  function Child(name, age) {
  Parent.call(this, name, age) //在子类中调用父类的方法,并改变父类的this指向
  }
  ```

- - 可以将父类私有的变成子类私有的,但是不能访问父类原型上的属性和方法
  - 可以传参可以实现多继承
  - 不能实现函数的复用,每个子类实例都会重新调用父类实例函数

- 组合继承

  ```
  function Parent(name,age) {
  
  }
  function Child(name, age) {
    Parent.call(this, name, age) //在子类中调用父类的方法,并改变父类的this指向
  }
  Child.prototype = new parent()
  ```

- - 父类私有的属性和方法变成子类私有的属性和方法,父类公有的属性和方法变成子类共同的属性和方法
  - 函数可复用可传参
  - 调用了两次父类构造函数，生成了两份实例

- 组合继承优化

  ```
  function Parent(name,age) {
  
  }
  
  function Child(name, age) {
  
  Parent.call(this, name, age) *//在子类中调用父类的方法,并改变父类的this指向*
  
  }
  
  //var B = Object,create(A),以A为对象创建B对象,B对象继承A的所有属性和方法*
  
  Child.prototype = Object.create(Parent)
  
  Child.prototype.constructor = Child
  ```

- - 这个继承解决了上面继承的所有缺点,是ES5最完美的继承方式,比较推荐

- ES6继承

  ```
  class Parent {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  }
  class Child extends Parent {
  constructor(name,age) {
    super(name, age) //通过super调用父类方法
  }
  }
  ```

- - 用类来定义构造函数,在constructor()里面定义构造函数的私有属性
  - 通过extends实现类的继承,在子类的constructor()的第一行写下super(),来实现子类的私有属性继承父类的私有属性