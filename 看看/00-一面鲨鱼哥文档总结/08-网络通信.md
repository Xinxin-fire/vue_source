## 网络通信

### 一、什么是HTTP协议

HTTP协议定义了客户端如何从Web服务器请求页面，以及服务器如何把Web页面传送给客户端的规范；

HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态作为响应，响应的内容包括：协议版本、状态码、服务器信息、响应头部和响应数据

HTTP是无状态协议，因此连接双方不能知晓对方当前的身份状态，浏览器会根据从服务器端发送的响应报文内set-Cookie首部字段信息自动保持Cookie。而每次客户端发送HTTP请求，都会在请求报文中携带cookie，作为服务端识别客户端身份状态的标识。

### 二、HTTP版本及其区别

#### HTTP/1.0

最早的HTTP版本只是使用一些较为简单的网络请求，每次请求都会打开新的TCP连接，收到响应后立即断开连接

#### HTTP/1.1

 **缓存处理**：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

**允许范围请求**，即在请求头中加入Range头部

**请求消息和响应消息都必须包含Host头部**，以区分同一个物理主机中不同虚拟主机的域名

**默认开启持久连接**，在以TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟

#### HTTP/2.0

帧：代表数据传输的最小单位

流：由多个帧组成的数据流，每个流表示一种请求

**二进制格式**：HTTP/1.x的解析是基于文本的，基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景必然很多，基于这种考虑**HTTP/2.0的协议解析采用二进制格式**，方便且强大。

**多路复用**：同一tcp连接中允许同时存在多个流，也就是可以同时发送多个请求，服务端可以通过帧的标识知道该帧属于哪个流，多路复用允许并发的发起多个请求，每个请求及该请求的响应不需要等待其他的请求或响应，避免了线头阻塞问题。

**头部压缩**：HTTP/1.x的请求和响应头部带有大量信息，而且每次请求都要重复发送，HTTP/2.0使用encoder来减少需要传输的头部大小，通讯双方各自cache一份头部 fields表，既避免了重复头部的传输，又减小了需要传输的大小。

**服务端推送：** 这里的服务端推送指把客户端所需要的css/js/img资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤（从缓存中取）。

### 三、HTTP报文

![image-20210326072033523](C:\Users\13166\AppData\Roaming\Typora\typora-user-images\image-20210326072033523.png)

#### ![image-20210326072546874](C:\Users\13166\AppData\Roaming\Typora\typora-user-images\image-20210326072546874.png)

### 四、HTTP缓存

#### 强制缓存

通过HTTP响应报文中的Cache-Control和Expires控制，若命中强制缓存则直接从缓存里取，不发起请求

#### 协商缓存

浏览器会先发起一个请求携带一个字段给服务器去判断，若字段（Last-Modified/If-Modified-Since或`If-no-match`/Etag）相等则返回304，表示未修改，可以直接从缓存里获取，若字段不等则重新发起请求

### 五、HTTPS

#### 什么是HTTPS

HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP的安全版

#### 对称秘钥

- 服务器向客户端发送一份加密过的数据，同时发送秘钥
- 客户端通过秘钥对数据进行解密

#### 非对称秘钥

- 服务器向客户端发送一份用私钥加密过的数据
- 客户端用公钥进行解密
- 公钥所有人都有，私钥只有服务器才有，可以保证服务器发的内容不能被伪造
- 同时客户端可以用公钥对数据进行加密，此时只有服务器才能通过私钥解密看到原文
- 公钥加密的内容只有私钥可以解开，私钥加密的内容公钥可以解开（私钥只保存在服务端）
- 公钥由权威机构发布，内置在浏览器中，若服务器发过来的公钥被串改，则客户端不能识别该公钥，匹配便会失败

#### HTTPS加密过程

客户端发起请求，服务器收到请求并返回公钥证书

客户端验证公钥证书，验证成功后，生成随机值（散列函数），使用公钥加密随机值，并发送给服务器

服务器通过私钥解密得到随机值，通过随机值对信息进行对称加密并发送给客户端

客户端收到信息并通过随机值解密，后面服务器和客户端可以通过这个随机值进行通信

#### HTTPS与HTTP的区别

HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;

HTTPS需要用到SSL证书（收费），而HTTP不用;

HTTPS标准端口443，HTTP标准端口80;

HTTPS基于传输层，HTTP基于应用层;

HTTPS的性能消耗要大于HTTP

### 六、TCP连接

#### 三次握手建立连接

- 客户端发送SYN，表明要向服务器建立连接，同时带上序列号ISN
- 服务器收到后。返回ACK（序号为客户端序列号+1）作为确认，同时发送SYN作为应答（SYN的序列号为服务端唯一的序号）
- 客户端发送ACK确认收到回复（序列号为服务端序列号+1）

#### 为什么是三次握手？

- TCP连接是双向的，要确保双方同时能发送数据和接收数据
- 第一次握手：证明了发送方能发送数据
- 第二次握手：ack确保了接收方能接收数据，SYN确保了接收方能发数据
- 第三次握手：确保了发送方能接收数据
- 四次握手会造成连接过程中性能的浪费，两次握手不能保证双方同时具备接收和发送数据的能力

#### 四次挥手断开连接

- 客户端发送FIN表示要关闭数据连接
- 服务端收到FIN后，发送ACK作为确认（序列号为收到的序列号+1）
- 等服务器数据传输完毕，也发送一个FIN标识，表示关闭这个方向的数据传输
- 客户端回复ACK确认回复

#### 为什么是四次挥手

- tcp连接是双向的，需要保证数据在两个方向上能同时传递
- 同时tcp支持半关闭（发送一方结束发送还能接收数据）
- 因此每个方向都要单独关闭，且收到关系通知需要发送确认回复

#### TCP和UDP的区别

### 七、从URL到页面显示发生了什么

### 八、跨域

#### 什么是跨域？

当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为跨域请求。

#### 浏览器的同源策略

浏览器遵循同源政策（协议、主机、端口号都相同则为同源），非同源站点有这样一些限制：

- 不能读取和修改对方的 DOM
- 不读访问对方的 Cookie、IndexDB 和 LocalStorage
- **限制 XMLHttpRequest 请求**。

#### 浏览器拦截响应的过程

跨域请求的响应一般会被浏览器所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了

在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有cors(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的

#### 如何解决跨域

- JSONP
  - 通过script的标签上src填上目标地址来发起get请求，实现跨域请求并拿到响应
  - 





