## 01-HTTP

### 一、什么是HTTP协议

- Web通过HTTP（超文本传输协议）的协议作为规范，完成客户端到服务器等一系列运作流程
- HTTP协议采用了请求/响应模型，客户端向服务器发送一个请求报文，请求报文包含：
  - 请求的方法、URL、协议版本、请求头部和请求数据
- 服务则以一个状态作为响应，响应的内容包括：
  - 协议版本、成功或错误代码、服务器信息、响应头部和响应数据

### 二、TCP/IP协议

- TCP/IP协议是internet中最基本的协议，http是它的子集，TCP/IP协议按层次可分为以下四层
  - **应用层：**规定了向用户提供应用服务时通信的协议，如：FTP（文件传输协议）、DNS域名系统（提供域名到IP地址之间的解析服务）及HTTP协议
  - **传输层：**传输层对接上层应用层，提供处于网络连接中两台计算机之间的数据传输所使用的协议，主要有TCP协议和UDP协议
    - TCP协议是双向的，即发送数据和接收数据是同步进行的，TCP在建立连接和断开连接时要经过三次握手和四次挥手，因此在传输中更稳定可靠，但是没有UDP那么高效
    - UDP协议是面向无连接的，且不保证有序，不丢失的传递到对端
  - **网络层：**网络层规定了数据通过怎样的传输路线到达对方计算机传输给对方（IP协议等）。
  - **链路层：**用来处理连接网络的硬件部分，包括控制操作系统、硬件设备驱动、NIC等

- 客户端向服务器发送一个请求报文，在应用层经过DNS域名解析和HTTP协议后到达传输层，在传输层通过TCP协议或者UDP协议向服务器发送数据，通过网络层决定了数据的传输路线，再通过链路层告诉服务器的操作系统已发送的数据，服务器通过链路层将返回一个数据，通过网络层指定了数据传递的路线，通过TCP协议或者UDP协议向客户端发送数据，在应用层通过hTTP协议客户端收到数据

### 三、串行连接、持久连接、管道化持久连接、http/2.0多路复用简介

- **串行连接：**每次连接只能处理一个请求，收到响应后立即断开连接，每个新的HTTP请求都需要建立一个新的连接
- **持久连接：**一定时间内，同一域名下的HTTP请求，只要两端都没有提出断开连接，则持久保持TCP连接状态，其他请求可以复用这个连接通道，但是持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着（就是常说的线头阻塞）。
- **管道化持久连接：** 管道化则可以不用等待响应返回而发送下个请求并按顺序返回响应，现代浏览器并未默认开启管道化
- **HTTP/2.0多路复用：** 每个HTTP请求都有一个序列标识符，这样浏览器可以并发多个请求，服务器接收到数据后，再根据序列标识符重新排序成不同的请求报文，而不会导致数据错乱，同样，服务端也可以并发返回多个响应给浏览器，浏览器收到后根据序列标识重新排序并归入各自的请求的响应报文。并且同一个域名下的所有请求都复用同一个TCP连接，极大增加了服务器处理并发的上限。
- **WebSocket：**WebSocket是HTML5提出的一种客户端和服务端通讯的全双工协议，由客户端发起请求，建立连接之后不仅客户端可以主动向服务端发送请求，服务端可以主动向客户端推送信息。

### 四、URI

HTTP协议使用 URI 定位互联网上的资源。概念：

- URI(Universal Resource Identifier：统一资源标识符)
- URL(Universal Resource Locator：统一资源定位符)
- URN(Universal Resource Name：统一资源名称)。

个人理解URI是一个资源文件的不同表示方法的总称。比如一个文件 a.html ，既可以用这个文件的名字 a.html 来表示，也可以用文件路径 www.baidu.com/a.html来表示，甚至可以用 urn:\a:1535-3613 这样的标识符来表示。

### 五、HTTP版本

- **HTTP/1.0：**每次请求都打开一个新的TCP链接，收到响应之后立即断开连接。
- **HTTP/1.1：**
  - 引入了缓存控制策略
  - 允许范围请求，即在请求头中加入`Range`头部
  - 请求消息和响应消息都必须包含Host头部，以区分同一个物理主机中的不同虚拟主机的域名
  - HTTP/1.1 默认开启持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。
- **HTTP/2.0：**
  - 采用二进制格式：HTTP/1.x的解析是基于文本的，文本考虑的场景很多，用二进制方便且强大
  - 多路复用：在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求
  - 头部压缩：HTTP/1.x的请求和响应头部带有大量信息，而且每次请求都要重复发送，HTTP/2.0使用encoder来减少需要传输的头部大小，通讯双方各自cache一份头部 fields表，既避免了重复头部的传输，又减小了需要传输的大小
  - 服务器推送：这里的服务端推送指把客户端所需要的css/js/img资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤（从缓存中取）。

### 六、HTTP报文

- 用于HTTP协议交互的信息被称为HTTP报文，客户端的HTTP报文叫请求报文，服务端的HTTP报文叫响应报文
- 请求报文是由请求行（请求方法、协议版本）、请求头部（请求URI、客户端信息等）和内容实体构成
- 响应报文是由状态行（协议版本、状态码）、响应首部（服务器名称、资源标识等）和内容实体构成

### 七、浏览器缓存

- 浏览器缓存可以分为两类：强缓存和协商缓存

**强缓存**

- 浏览器在加载资源时，会先根据本地缓存资源的header中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源，不会向服务器发送请求
- 判断是否命中强缓存主要看Expire和Cache-control两个字段
  - Expires:Fri, 27 Oct 2017 07:55:30 GMT，这个字段包含了一个时间，如果过了这个时间响应将会失效，而且这是个决定时间
  - Cache-Control:max-age=600，通过Cache-control字段可以设置相对时间，单位：秒，Cache-control除了max-age属性外还有一些属性：
    - no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。
    - no-store：禁止使用缓存，每一次都要重新请求数据。
    - public：默认设置。
    - private：不能被多用户共享。
- 可以同时设置 `Expire` 和 `Cache-Control` ，`Cache-Control` 的优先级别更高

**协商缓存**

- 当强缓存没有命中时，浏览器会发送一个请求到服务器，服务器根据请求头中的部分信息来判断是否命中缓存，如果命中，则返会304，告诉浏览器资源未更新，可使用本地缓存
- 通过Last-Modified，If-Modified-Since判断资源是否修改
  - Last-Modified: Fri, 27 Oct 2017 07:55:30 GMT，第一次请求服务器返回的header会带有Last-Modified字段，当浏览器再次请求资源时会在请求头中带有If-Modified-Since字段，服务器会将这个字段和Last-Modified作对比，如果相等则说明资源未修改返回304

- Etag由文件内容的hash生成可保证资源的唯一性
  - 在浏览器第一次请求资源时服务器会返回Etag标识，当再次请求该资源时会通过`If-no-match` 字段将 `Etag` 发送回服务器，然后服务器进行比较，如果相等，则返回 `304` 表示未修改。

- `Last-Modified` 和 `Etag` 是可以同时设置的，服务器会优先校验 `Etag`，如果 `Etag` 相等就会继续比对 `Last-Modified`，最后才会决定是否返回 `304`。





