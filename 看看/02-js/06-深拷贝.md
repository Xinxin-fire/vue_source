## 06-深拷贝

### 一、数据类型

- 基础类型

  - Boolean  布尔类型：有两个值，true和false

  - Null  一个变量未被声明时则为null 

    - ```javascript
      typeof null == 'object'
      ```

  - Undefined  一个变量声明但未被赋值时则为undefined

  - Number  数字类型

  - Biglnt  数字类型，用于存储和操作大整数

  - String  字符串类型

  - Symbol  符号类型，可以用来表示Object的key值的唯一性

- 引用类型

  - Object（数组，函数都属于对象）

### 二、浅拷贝

- 对于基础数据类型而言，没有深浅拷贝之分，我们所说的深浅拷贝都是对于引用数据类型而言的
- 浅拷贝：即只复制引用，而未复制真正的值
- 浅拷贝的方法：
  - "="等号赋值，只拷贝对象的引用值
  - 数组方法拷贝，concat()和slice(),只是对数组的第一层进行拷贝
  - 对象方法拷贝，Object.assign(),只拷贝对象的引用值
  - ...操作符，只是对数组或对象的第一层进行拷贝

### 三、深拷贝

- JSON.parse(JSON.stringify(obj))
  
  - 此方法可以实现对象的深拷贝，但是当对象中含有undefined、function、symbol等属性时，在转换时会被忽略
  
- 递归

  ```javascript
  function deepCopy(obj) {
      if(obj ===null || typeof obj !== 'object'  ) {
          return obj;
      }
      let newObj = Array.isArray(obj) ? [] : {};
      let symKeys = Object.getOwnPropertySymbols(source); // 查找
      if (symKeys.length) { // 查找成功	
          symKeys.forEach(symKey => {
              if (typeof source[symKey] == 'object' && source[symKey] != null) {
                  newObj[symKey] = deepCopy(source[symKey]); 
              } else {
                  newObj[symKey] = source[symKey];
              }    
          });
      }
      for (let i in obj) {
          if(typeof obj[i] == 'object' && obj != null) {
              newObj[i] = deepCopy(obj[i]);
          } else {
              newObj[i] = obj[i]; 
          }
      }
      return newObj;
  }
  ```

  - 注意的问题：
    1. 对传入参数的校验，已解决
    2. 对数组的兼容，已解决
    3. 无法深拷贝循环引用，待解决 可以考虑使用数组保存新创建的对象和复制对象，将其进行比较
    4. 拷贝Symbol，已解决
    5. 递归爆栈的问题，未解决，可以使用循环，或者使用setTimeout分片