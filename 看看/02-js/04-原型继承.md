## 04-原型/继承	

### 一、原型

1.prototype的定义

- 给其它对象提供共享属性的对象

2.一个对象如何为另一个对象提供属性访问呢

- 所有的object都有一个隐式引用，它被称之为这个对象的prototype原型

### 二、函数对象和普通对象

所有的Function的实例都是函数对象，即函数对象的构造函数为Function；其它的均为普通对象。

_\_proto\_\_和constructor是对象独有的,但是prototype是函数对象独有的

### 三、对象的prototype对象的访问

- 通过 `Object.getPrototypeOf(obj)` 间接访问指定对象的 `prototype` 对象
- 通过 `Object.setPrototypeOf(obj, anotherObj)` 间接设置指定对象的 `prototype` 对象

#### 四、原型链

```javascript
function A () {}
let b = new A()
b.__proto__ === A.prototype //true
b.constructor === b.__proto__.constructor === A.prototype.constructor === A //true
```

- 如上，b为A的实例对象，所以b的隐式原型指向A的显式原型（**实例对象的隐式原型指向其构造函数的显式原型**）
- A为构造函数，b是被A构造出来的，所以b的constructor等于函数A，且b的隐式原型的constructor也等于A，由于b的隐式原型等于A的显示原型，则A的原型的constructor也等于A

```javascript
A.prototype.__proto__ === Object.prototype //true
Object.prototype.__proto__ === null //true
Object.prototype.constructor === Object // true
```

- 由于A.prototype也是一个对象，所以A.prototype是Object的实例对象

```javascript
Function.constructor === Function // true
Function.prototype === Function.__proto__ //true
Function.prototype === Object.__proto__ //true
Function.prototype === A.__proto__ //true
```

- **Function是所有函数对象的构造函数（包括Object和其本身），所以所有函数的隐式原型都指向Function的显式原型**

```javascript
Function.prototype.__proto__ === Object.prototype
Object.__proto__.__proto__.__proto__ === null //true
```

- **除了Object本身，其他函数对象的prototype都是Object的实例对象（包括Function.prototype）** 

#### 五、instanceof

instanceof用来判断一个实例是否是其父类型或者祖先类型的实例。

```javascript
Object instanceof Object //true
Function instance Function //true
```

### 六、new

- new操作符干了什么
  - 创建一个空对象
  - 将空对象的隐式原型指向构造函数的显式原型
  - 将空对象的constructor属性指向构造函数
  - 将构造函数中的this指向这个空对象
- 访问到构造函数中的属性
- 访问到构造函数的prototype属性

```
function 
```

1. new做了什么
   - 通过new可以创造一个构造函数的实例
   - 该实例对象可以访问构造函数prototype上的方法
   - 该实例对象可以访问构造函数的私有属性
2. 具体实现
   - 创造一个空对象
   - 将该空对象的隐式原型指向构造函数的显式原型
   - 将构造函数的this指向该空对象