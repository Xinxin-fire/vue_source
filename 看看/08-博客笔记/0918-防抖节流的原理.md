### 0918-防抖节流的原理

##### 一、什么是防抖节流

函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

函数节流：通过定时器定时，每隔一段时间执行一次函数。

上面的概念大家可能理解起来比较困难，这里我举两个生活中的例子：

##### 二、防抖节流的应用场景

1.当我们在百度搜索时，底下会不断的根据我们输入的内容进行提示，但是如果我们输入过快的话，它会等一会到我们停下时再根据我们输入的内容匹配提示，这就是函数防抖。

2.在我们逛淘宝时，相信大家都有过这样一个经历，我们不断的下拉屏幕，不断的触发下拉加载更多，但是基本上它下拉刷新的频率是一样的，跟我们的手速无关，而这就是引用了函数节流

函数防抖和函数节流都是为了防止一个时间段内，事件调用的过于频繁，用来优化高频率执行js代码的一种手段

那么了解了防抖节流的概念和应用场景之后，我们应该怎样实现它呢！

##### 三、防抖节流的实现

1.函数防抖：

```
function debounce(fn, interval) {
  let timeout = null;
  return function () {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
          fn.apply(this, arguments);
      }, interval);
  };
}
```

函数防抖执行的原理就是利用闭包将timeout作为标记，来保存setTimeout返回的值，当事件不断触发时，会不断的将定时器清除，直到在一定时间内没有重新触发事件，则事件会被执行。

2.函数节流

```
function throttle(fn, interval) {
  let exec = true;
  return function () {
      if (!exec) return;
      exec = false;
      setTimeout(() => {
          fn.apply(this, arguments);
          exec = true;
      }, interval);
  };
}
```

函数节流也是同理，通过闭包保存exec变量作为标记，初始化使exec为true，使其可以执行语句，进入到执行语句里将其置为false，防止事件被频繁执行，直到定时器时间结束，事件被执行，再将exec置为true使其可以重新执行。



作为开发人员，产品性能一直是开发需要密切关注的，如果本期内容帮到你的话请点个赞吧！