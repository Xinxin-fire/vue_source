### 1. React 的生命周期有哪些？

React 通常将组件生命周期分为三个阶段：

- 装载阶段（Mount），组件第一次在 DOM 树中被渲染的过程；
- 更新过程（Update），组件状态发生变化，重新更新渲染的过程；
- 卸载过程（Unmount），组件从 DOM 树中被移除的过程；

![image.png](https://cdn.nlark.com/yuque/0/2021/png/1500604/1611914193870-a5a93315-a094-40aa-959a-e3e3c58c8a96.png?x-oss-process=image%2Fresize%2Cw_1500)

#### 1）组件挂载阶段

挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：

- constructor
- getDerivedStateFromProps
- render
- componentDidMount

##### （1）constructor

组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 `super(props)`，否则无法在构造函数中拿到 this。

如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数**Constructor**。

constructor 中通常只做两件事：

- 初始化组件的 state
- 给事件处理方法绑定 this

```
constructor(props) {
  super(props);
  // 不要在构造函数中调用 setState，可以直接给 state 设置初始值
  this.state = { counter: 0 }
  this.handleClick = this.handleClick.bind(this)
}
```

##### （2）getDerivedStateFromProps

```
static getDerivedStateFromProps(props, state)
```

这是个静态方法，所以不能在这个函数里使用 `this`，有两个参数 `props` 和 `state`，分别指接收到的新参数和当前组件的 `state` 对象，这个函数会返回一个对象用来更新当前的 `state` 对象，如果不需要更新可以返回 `null`。

该函数会在装载时，接收到新的 `props` 或者调用了 `setState` 和 `forceUpdate` 时被调用。如当接收到新的属性想修改 `state` ，就可以使用。

```javascript
// 当 props.counter 变化时，赋值给 state
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      counter: 0,
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (props.counter !== state.counter) {
      return {
        counter: props.counter,
      };
    }
    return null;
  }

  handleClick = () => {
    this.setState({
      counter: this.state.counter + 1,
    });
  };
  render() {
    return (
      <div>
        <h1 onClick={this.handleClick}>Hello, world!{this.state.counter}</h1>
      </div>
    );
  }
}
```

现在可以显式传入 `counter` ，但是这里有个问题，如果想要通过点击实现 `state.counter` 的增加，但这时会发现值不会发生任何变化，一直保持 `props` 传进来的值。这是由于在 React 16.4^ 的版本中 `setState` 和 `forceUpdate` 也会触发这个生命周期，所以当组件内部 `state` 变化后，就会重新走这个方法，同时会把 `state` 值赋值为 `props` 的值。因此需要多加一个字段来记录之前的 `props` 值，这样就会解决上述问题。具体如下：

```
// 这里只列出需要变化的地方
class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      // 增加一个 preCounter 来记录之前的 props 传来的值
      preCounter: 0,
      counter: 0
    }
  }
  static getDerivedStateFromProps(props, state) {
    // 跟 state.preCounter 进行比较
    if (props.counter !== state.preCounter) {
      return {
        counter: props.counter,
        preCounter: props.counter
      }
    }
    return null
  }
  handleClick = () => {
    this.setState({
      counter: this.state.counter + 1
    })
  }
  render() {
    return (
      <div>
        <h1 onClick={this.handleClick}>Hello, world!{this.state.counter}</h1>
      </div>
    )
  }
}
```

##### （3）render

render 是 React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 `state` 和属性 `props` 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：

- **React 元素**：这里包括原生的 DOM 以及 React 组件；
- **数组和 Fragment（片段）**：可以返回多个元素；
- **Portals（插槽）**：可以将子元素渲染到不同的 DOM 子树种；
- **字符串和数字**：被渲染成 DOM 中的 text 节点；
- **布尔值或 null**：不渲染任何内容。

##### （4）componentDidMount()

componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：

- 执行依赖于 DOM 的操作；
- 发送网络请求；（官方建议）
- 添加订阅消息（会在 componentWillUnmount 取消订阅）；

如果在 `componentDidMount` 中调用 `setState` ，就会触发一次额外的渲染，多调用了一次 `render` 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 `constructor` 中初始化 `state` 对象。

在组件装载之后，将计数数字变为 1：

```
class App extends React.Component  {
  constructor(props) {
    super(props)
    this.state = {
      counter: 0
    }
  }
  componentDidMount () {
    this.setState({
      counter: 1
    })
  }
  render ()  {
    return (
      <div className="counter">
        counter值: { this.state.counter }
      </div>
    )
  }
}
```

#### 2）组件更新阶段

当组件的 `props` 改变了，或组件内部调用了 `setState/forceUpdate`，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：

- getDerivedStateFromProps
- shouldComponentUpdate
- render
- getSnapshotBeforeUpdate
- componentDidUpdate

##### （1）shouldComponentUpdate

```
shouldComponentUpdate(nextProps, nextState)
```

在说这个生命周期函数之前，来看两个问题：

- **setState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：**

```
this.setState({number: this.state.number})
```

- **如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？**

第一个问题答案是 **会** ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。

那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 `shouldComponentUpdate` 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 `true`，可以比较 `this.props` 和 `nextProps` ，`this.state` 和 `nextState` 值是否变化，来确认返回 true 或者 `false`。当返回 `false` 时，组件的更新过程停止，后续的 `render`、`componentDidUpdate` 也不会被调用。

**注意：**添加 `shouldComponentUpdate` 方法时，不建议使用深度相等检查（如使用 `JSON.stringify()`），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。

##### （2）getSnapshotBeforeUpdate

```
getSnapshotBeforeUpdate(prevProps, prevState)
```

这个方法在 `render` 之后，`componentDidUpdate` 之前调用，有两个参数 `prevProps` 和 `prevState`，表示更新之前的 `props` 和 `state`，这个函数必须要和 `componentDidUpdate` 一起使用，并且要有一个返回值，默认是 `null`，这个返回值作为第三个参数传给 `componentDidUpdate`。

##### （3）componentDidUpdate

componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：

- 当组件更新后，对 DOM 进行操作；
- 如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。

```
componentDidUpdate(prevProps, prevState, snapshot){}
```

该方法有三个参数：

- prevProps: 更新前的 props
- prevState: 更新前的 state
- snapshot: getSnapshotBeforeUpdate()生命周期的返回值

#### 3）组件卸载阶段

卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：

- 清除 timer，取消网络请求或清除
- 取消在 componentDidMount() 中创建的订阅等；

这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 `setState`，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。

#### 4）错误处理阶段

componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数 ∶

- error：抛出的错误。
- info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息

React 常见的生命周期如下：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1500604/1606974748814-56e52599-8cda-4305-8135-eaf64d75fbb9.png)

**React 常见生命周期的过程大致如下：**

- 挂载阶段，首先执行 constructor 构造方法，来创建组件
- 创建完成之后，就会执行 render 方法，该方法会返回需要渲染的内容
- 随后，React 会将需要渲染的内容挂载到 DOM 树上
- **挂载完成之后就会执行\*\***componentDidMount 生命周期函数\*\*
- 如果我们给组件创建一个 props（用于组件通信）、调用 setState（更改 state 中的数据）、调用 forceUpdate（强制更新组件）时，都会重新调用 render 函数
- render 函数重新执行之后，就会重新进行 DOM 树的挂载
- **挂载完成之后就会执行\*\***componentDidUpdate 生命周期函数\*\*
- **当移除组件时，就会执行\*\***componentWillUnmount 生命周期函数\*\*

**React 主要生命周期总结：**

1. **getDefaultProps**：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；
2. **getInitialState**：用于初始化组件的 state 值；
3. **componentWillMount**：在组件创建后、render 之前，会走到 componentWillMount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来 React 官方已经不推荐大家在 componentWillMount 里做任何事情、到现在 **React16 直接废弃了这个生命周期**，足见其鸡肋程度了；
4. **render**：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；
5. **componentDidMount**：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。

### 2. React 性能优化在哪个生命周期？它优化的原理是什么？

react 的父级组件的 render 函数重新渲染会引起子组件的 render 方法的重新渲染。但是，有的时候子组件的接受父组件的数据没有变动。子组件 render 的执行会影响性能，这时就可以使用 shouldComponentUpdate 来解决这个问题。

使用方法如下：

```javascript
shouldComponentUpdate(nexrProps) {
    if (this.props.num === nexrProps.num) {
        return false
    }
    return true;
}
```

shouldComponentUpdate 提供了两个参数 nextProps 和 nextState，表示下一次 props 和一次 state 的值，当函数返回 false 时候，render()方法不执行，组件也就不会渲染，返回 true 时，组件照常重渲染。此方法就是拿当前 props 中值和下一次 props 中的值进行对比，数据相等时，返回 false，反之返回 true。

需要注意，在进行新旧对比的时候，是**浅对比，**也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为 true。

面对这个问题，可以使用如下方法进行解决：

（1）使用 setState 改变数据之前，先采用 ES6 中 assgin 进行拷贝，但是 assgin 只深拷贝的数据的第一层，所以说不是最完美的解决办法：

```
const o2 = Object.assign({},this.state.obj)
    o2.student.count = '00000';
    this.setState({
        obj: o2,
    })
```

（2）使用 JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为 undefined 和函数时就会错。

```
const o2 = JSON.parse(JSON.stringify(this.state.obj))
    o2.student.count = '00000';
    this.setState({
        obj: o2,
    })
```

### 3. state 和 props 触发更新的生命周期分别有什么区别？

**state 更新流程：**

![image](https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1616079696588-fe9625ce-a23f-42ef-ae52-247b29b5ee3c.jpeg)

这个过程当中涉及的函数：

1. shouldComponentUpdate: 当组件的 state 或 props 发生改变时，都会首先触发这个生命周期函数。它会接收两个参数：nextProps, nextState——它们分别代表传入的新 props 和新的 state 值。拿到这两个值之后，我们就可以通过一些对比逻辑来决定是否有 re-render（重渲染）的必要了。如果该函数的返回值为 false，则生命周期终止，反之继续；

> 注意：此方法仅作为**性能优化的方式**而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。应该**考虑使用内置的 PureComponent 组件**，而不是手动编写 `shouldComponentUpdate()`

1. componentWillUpdate：当组件的 state 或 props 发生改变时，会在渲染之前调用 componentWillUpdate。componentWillUpdate **是 React16 废弃的三个生命周期之一**。过去，我们可能希望能在这个阶段去收集一些必要的信息（比如更新前的 DOM 信息等等），现在我们完全可以在 React16 的 getSnapshotBeforeUpdate 中去做这些事；
2. componentDidUpdate：componentDidUpdate() 会在 UI 更新后会被立即调用。它接收 prevProps（上一次的 props 值）作为入参，也就是说在此处我们仍然可以进行 props 值对比（再次说明 componentWillUpdate 确实鸡肋哈）。

**props 更新流程：**

![image](https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1616079696446-71709f4d-1b94-4405-9538-5167ed5e4f2a.jpeg)

相对于 state 更新，props 更新后唯一的区别是增加了对 componentWillReceiveProps 的调用。关于 componentWillReceiveProps，需要知道这些事情：

- componentWillReceiveProps：它在 Component 接受到新的 props 时被触发。componentWillReceiveProps 会接收一个名为 nextProps 的参数（对应新的 props 值）。**该生命周期是 React16 废弃掉的三个生命周期之一**。在它被废弃前，可以用它来比较 this.props 和 nextProps 来重新 setState。在 React16 中，用一个类似的新生命周期 getDerivedStateFromProps 来代替它。

### 4. React 中发起网络请求应该在哪个生命周期中进行？为什么？

对于异步请求，最好放在 componentDidMount 中去操作，对于同步的状态改变，可以放在 componentWillMount 中，一般用的比较少。

如果认为在 componentWillMount 里发起请求能提早获得结果，这种想法其实是错误的，通常 componentWillMount 比 componentDidMount 早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。

**react 的生命周期：**constructor() -> componentWillMount() -> render() -> componentDidMount()

上面这些方法的调用是有次序的，由上而下依次调用。

- constructor 被调用是在组件准备要挂载的最开始，此时组件尚未挂载到网页上。
- componentWillMount 方法的调用在 constructor 之后，在 render 之前，在这方法里的代码调用 setState 方法不会触发重新 render，所以它一般不会用来作加载数据之用。
- componentDidMount 方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用 setState 方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在 constructor 里做，但 constructor 是做组件 state 初绐化工作，并不是做加载数据这工作的，constructor 里也不能 setState，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在 componentDidMount 方法里。

总结：

- 跟服务器端渲染（同构）有关系，如果在 componentWillMount 里面获取数据，fetch data 会执行两次，一次在服务器端一次在客户端。在 componentDidMount 中可以解决这个问题，componentWillMount 同样也会 render 两次。
- 在 componentWillMount 中 fetch data，数据一定在 render 后才能到达，如果忘记了设置初始状态，用户体验不好。
- react16.0 以后，componentWillMount 可能会被执行多次。

### 5. React 的事件和普通的 HTML 事件有什么不同？

区别：

- 对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；
- react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用`preventDefault()`来阻止默认行为。
- 对于事件函数处理语法，原生事件为字符串，react 事件为函数；

React 合成事件机制: React 并不是将事件直接绑定在 dom 上面,而是采用事件冒泡的形式冒泡到 document 上面,然后 React 将事件封装给正式的函数处理运行和处理。其优点如下：

- 兼容所有浏览器，更好的跨平台；
- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。
- 方便 react 统一管理和事务机制。

事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到 document 上合成事件才会执行

`React`事件机制总结如下：

- React 上注册的事件最终会绑定在 document 这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)
- React 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。
- React 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback
- React 有一套自己的合成事件 SyntheticEvent

### 6.`React`事件和原生事件的执行顺序

```jsx
import React from "react";
class App extends React.Component {
  constructor(props) {
    super(props);
    this.parentRef = React.createRef();
    this.childRef = React.createRef();
  }
  componentDidMount() {
    console.log("React componentDidMount！");
    this.parentRef.current?.addEventListener("click", () => {
      console.log("原生事件：父元素 DOM 事件监听！");
    });
    this.childRef.current?.addEventListener("click", () => {
      console.log("原生事件：子元素 DOM 事件监听！");
    });
    document.addEventListener("click", (e) => {
      console.log("原生事件：document DOM 事件监听！");
    });
  }
  parentClickFun = () => {
    console.log("React 事件：父元素事件监听！");
  };
  childClickFun = () => {
    console.log("React 事件：子元素事件监听！");
  };
  render() {
    return (
      <div ref={this.parentRef} onClick={this.parentClickFun}>
        <div ref={this.childRef} onClick={this.childClickFun}>
          分析事件执行顺序
        </div>
      </div>
    );
  }
}
export default App;
```

执行结果：

```tex
原生事件：子元素 DOM 事件监听！
原生事件：父元素 DOM 事件监听！
React 事件：子元素事件监听！
React 事件：父元素事件监听！
原生事件：document DOM 事件监听！
```

由上面的流程我们可以理解：

- `react`的所有事件都挂载在`document`中
- 当真实 dom 触发后冒泡到`document`后才会对`react`事件进行处理
- 所以原生的事件会先执行
- 然后执行`react`合成事件
- 最后执行真正在`document`上挂载的事件

所以想要阻止不同时间段的冒泡行为，对应使用不同的方法，对应如下：

- 阻止合成事件间的冒泡，用 e.stopPropagation()
- 阻止合成事件与最外层 document 上的事件间的冒泡，用 e.nativeEvent.stopImmediatePropagation()
- 阻止合成事件与除最外层 document 上的原生事件上的冒泡，通过判断 e.target 来避免

![img](https://static.vue-js.com/08e22ff0-d870-11eb-ab90-d9ae814b240d.png)

### 7. 对 React-Fiber 的理解，它解决了什么问题？

React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，**导致用户感觉到卡顿**。

React Fiber 是 Facebook 花费两年余时间对 React 做出的一个重大改变与优化，是对 React 核心算法的一次重新实现。从 Facebook 在 React Conf 2017 会议上确认，React Fiber 在 React 16 版本发布

在`react`中，主要做了以下的操作：

- 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务
- 增加了异步任务，调用 requestIdleCallback api，浏览器空闲的时候执行
- dom diff 树变成了链表，一个 dom 对应两个 fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行

**从架构角度来看**，`Fiber` 是对 `React`核心算法（即调和过程）的重写

从数据结构来看，`Fiber`是 **静态节点信息** ， `React 16` 新架构下的虚拟`DOM`一个 `fiber`就是一个 `JavaScript`对象，包含了元素的信息、该元素的更新操作队列、类型。

作为**动态的工作单元**来说，每个 `Fiber` 节点保存了本次更新中该组件改变的状态、要执行的工作。

`Fiber`把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行

可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 `React Element` 对应的 `Fiber`节点,使用 `window.requestIdleCallback()`方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应

### 8. React 高阶组件是什么，和普通组件有什么区别，适用什么场景

官方解释 ∶

> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。

简言之，HOC 是一种组件的设计模式，HOC 接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。

```
// hoc的定义
function withSubscription(WrappedComponent, selectData) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        data: selectData(DataSource, props)
      };
    }
    // 一些通用的逻辑处理
    render() {
      // ... 并使用新数据渲染被包装的组件!
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };

// 使用
const BlogPostWithSubscription = withSubscription(BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id));
```

**1）HOC 的优缺点**

- 优点 ∶ 逻辑服用、不影响被包裹组件的内部逻辑。
- 缺点 ∶hoc 传递给被包裹组件的 props 容易和被包裹后的组件重名，进而被覆盖

**2）适用场景**

- 代码复用，逻辑抽象
- 渲染劫持
- State 抽象和更改
- Props 更改

**3）具体应用例子**

- **权限控制：**利用高阶组件的 **条件渲染** 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和 页面元素级别

```javascript
// HOC.js
function withAdminAuth(WrappedComponent) {
    return class extends React.Component {
        state = {
            isAdmin: false,
        }
        async UNSAFE_componentWillMount() {
            const currentRole = await getCurrentUserRole();
            this.setState({
                isAdmin: currentRole === 'Admin',
            });
        }
        render() {
            if (this.state.isAdmin) {
                return <WrappedComponent {...this.props} />;
            } else {
                return (<div>您没有权限查看该页面，请联系管理员！</div>);
            }
        }
    };
}

// pages/page-a.js
class PageA extends React.Component {
    constructor(props) {
        super(props);
        // something here...
    }
    UNSAFE_componentWillMount() {
        // fetching data
    }
    render() {
        // render page with data
    }
}
export default withAdminAuth(PageA);


// pages/page-b.js
class PageB extends React.Component {
    constructor(props) {
        super(props);
    // something here...
        }
    UNSAFE_componentWillMount() {
    // fetching data
    }
    render() {
    // render page with data
    }
}
export default withAdminAuth(PageB);
```

- **组件渲染性能追踪：**借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录 ∶

```javascript
class Home extends React.Component {
  render() {
    return <h1>Hello World.</h1>;
  }
}
function withTiming(WrappedComponent) {
  return class extends WrappedComponent {
    constructor(props) {
      super(props);
      this.start = 0;
      this.end = 0;
    }
    UNSAFE_componentWillMount() {
      super.componentWillMount && super.componentWillMount();
      this.start = Date.now();
    }
    componentDidMount() {
      super.componentDidMount && super.componentDidMount();
      this.end = Date.now();
      console.log(
        `${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`
      );
    }
    render() {
      return super.render();
    }
  };
}

export default withTiming(Home);
```

注意：withTiming 是利用 反向继承 实现的一个高阶组件，功能是计算被包裹组件（这里是 Home 组件）的渲染时间。

- **页面复用**

```javascript
const withFetching = fetching => WrappedComponent => {
    return class extends React.Component {
        state = {
            data: [],
        }
        async UNSAFE_componentWillMount() {
            const data = await fetching();
            this.setState({
                data,
            });
        }
        render() {
            return <WrappedComponent data={this.state.data} {...this.props} />;
        }
    }
}

// pages/page-a.js
export default withFetching(fetching('science-fiction'))(MovieList);
// pages/page-b.js
export default withFetching(fetching('action'))(MovieList);
// pages/page-other.js
export default withFetching(fetching('some-other-type'))(MovieList);
```

### 9.React 中 refs 的作用是什么？有哪些应用场景？

Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：

- 处理焦点、文本选择或者媒体的控制
- 触发必要的动画
- 集成第三方 DOM 库

Refs 是使用 `React.createRef()` 方法创建的，他通过 `ref` 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 `ref` 在构造函数中分配给其实例属性：

```javascript
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}
```

由于函数组件没有实例，因此不能在函数组件上直接使用 `ref`：

```javascript
function MyFunctionalComponent() {
  return <input />;
}
class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }
  render() {
    // 这将不会工作！
    return <MyFunctionalComponent ref={this.textInput} />;
  }
}
```

但可以通过闭合的帮助在函数组件内部进行使用 Refs：

```javascript
function CustomTextInput(props) {
  // 这里必须声明 textInput，这样 ref 回调才可以引用它
  let textInput = null;
  function handleClick() {
    textInput.focus();
  }
  return (
    <div>
      <input
        type="text"
        ref={(input) => {
          textInput = input;
        }}
      />
      <input type="button" value="Focus the text input" onClick={handleClick} />
    </div>
  );
}
```

**注意：**

- 不应该过度的使用 Refs
- `ref` 的返回值取决于节点的类型：

- 当 `ref` 属性被用于一个普通的 HTML 元素时，`React.createRef()` 将接收底层 DOM 元素作为他的 `current` 属性以创建 `ref`。

  - 当 `ref` 属性被用于一个自定义的类组件时，`ref` 对象将接收该组件已挂载的实例作为他的 `current`。

- 当在父组件中需要访问子组件中的 `ref` 时可使用传递 Refs 或回调 Refs。

### 10. 对 React context 的理解

在 React 中，数据传递一般使用 props 传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props 就需要层层传递显然，这样做太繁琐了。

Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。

可以把 context 当做是特定一个组件树内共享的 store，用来做数据传递。**简单说就是，当你不想在组件树中通过逐层传递 props 或者 state 的方式来传递数据时，可以使用 Context 来实现跨层级的组件数据传递。**

JS 的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时 JS 代码块执行期间所能访问的活动对象，包括变量和函数，JS 程序通过作用域链访问到代码块内部或者外部的变量和函数。

假如以 JS 的作用域链作为类比，React 组件提供的 Context 对象其实就好比一个提供给子组件访问的作用域，而 Context 对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的 Context 对象组合而成，所以，组件通过 Context 是可以访问到其父组件链上所有节点组件提供的 Context 的属性。

### 11. 类组件与函数组件有什么异同？

**相同点：**

组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。

我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。

**不同点：**

- 它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。
- 之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。
- 性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。
- 从上手程度而言，类组件更容易上手，从未来趋势上看，由于 React Hooks 的推出，函数组件成了社区未来主推的方案。
- 类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。

### 12.说说对受控组件和非受控组件的理解？应用场景？

**（1）受控组件**

在使用表单来收集用户输入时，例如 `<input><select><textearea>` 等元素都要绑定一个 change 事件，当表单的状态发生变化，就会触发 onChange 事件，更新组件的 state。这种组件在 React 中被称为**受控组件**，在受控组件中，组件渲染出的状态与它的 value 或 checked 属性相对应，react 通过这种方式消除了组件的局部状态，使整个状态可控。react 官方推荐使用受控表单组件。

受控组件更新 state 的流程：

- 可以通过初始 state 中设置表单的默认值
- 每当表单的值发生变化时，调用 onChange 事件处理器
- 事件处理器通过事件对象 e 拿到改变后的状态，并更新组件的 state
- 一旦通过 setState 方法更新 state，就会触发视图的重新渲染，完成表单组件的更新

**受控组件缺陷：**

表单元素的值都是由 React 组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。

**（2）非受控组件**

如果一个表单组件没有 value props（单选和复选按钮对应的是 checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个 ref 来从 DOM 获得表单值。而不是为每个状态更新编写一个事件处理程序。

React 官方的解释：

> 要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref 来从 DOM 节点中获取表单数据。
>
> 因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。

例如，下面的代码在非受控组件中接收单个属性：

```javascript
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
  handleSubmit(event) {
    alert("A name was submitted: " + this.input.value);
    event.preventDefault();
  }
  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref={(input) => (this.input = input)} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

**总结**页面中所有输入类的 DOM 如果是现用现取的称为非受控组件，而通过 setState 将输入的值维护到了 state 中，需要时再从 state 中取出，这里的数据就受到了 state 的控制，称为受控组件。

### 13. React Hooks 解决了哪些问题？

React Hooks 主要解决了以下问题：

**（1）在组件之间复用状态逻辑很难**

React 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）解决此类问题可以使用 render props 和 高阶组件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会使代码难以理解。由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。

可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使我们在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。

**（2）复杂组件变得难以理解**

在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。

在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。

为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。

**（3）难以理解的 class**

除了代码复用和代码管理会遇到困难外，class 是学习 React 的一大屏障。我们必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。

为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术

### 14. React Hook 的使用限制有哪些？

React Hooks 的限制主要有两条：

- 不要在循环、条件或嵌套函数中调用 Hook；
- 在 React 的函数组件中调用 Hook。

那为什么会有这样的限制呢？Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。

- 组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。
- 复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。
- 人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，希望在编译优化层面做出一些改进。

这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks **基于函数组件**开始设计。然而第三个问题决定了 Hooks 只支持函数组件。

那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。

这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。

### 15. useEffect 与 useLayoutEffect 的区别

**（1）共同点**

- **运用效果：**useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。
- **使用方式：**useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl 方法，在使用上也没什么差异，基本可以直接替换。

**（2）不同点**

- **使用场景：**useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。
- **使用效果：**useEffect 是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变 DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect 是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变 DOM 后渲染），不会产生闪烁。**useLayoutEffect 总是比 useEffect 先执行。**

在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。

### 16 为什么 useState 要使用数组而不是对象

useState 的用法：

```
const [count, setCount] = useState(0)
```

可以看到 useState 返回的是一个数组，那么为什么是返回数组而不是返回对象呢？

这里用到了解构赋值，所以先来看一下 ES6 的解构赋值：

##### 数组的解构赋值

```
const foo = [1, 2, 3];
const [one, two, three] = foo;
console.log(one);   // 1
console.log(two);   // 2
console.log(three); // 3
```

##### 对象的解构赋值

```
const user = {
  id: 888,
  name: "xiaoxin"
};
const { id, name } = user;
console.log(id);    // 888
console.log(name);  // "xiaoxin"
```

看完这两个例子，答案应该就出来了：

- 如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净
- 如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值

下面来看看如果 useState 返回对象的情况：

```
// 第一次使用
const { state, setState } = useState(false);
// 第二次使用
const { state: counter, setState: setCounter } = useState(0)
```

这里可以看到，返回对象的使用方式还是挺麻烦的，更何况实际项目中会使用的更频繁。

**总结：**useState 返回的是 array 而不是 object 的原因就是为了**降低使用的复杂度**，返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。

### 17 React Hooks 和生命周期的关系？

这个问题是个陷阱。函数组件和 class 组件的心智模型是不一样的，不能把他们混为一谈

**函数组件** 的本质是函数，没有 state 的概念的，因此**不存在生命周期**一说，仅仅是一个 **render 函数**而已。

但是引入 **Hooks** 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了代替生命周期的概念，所谓的周期其实就是 `useState`、 `useEffect()` 和 `useLayoutEffect()` 。

即：**Hooks 组件（使用了 Hooks 的函数组件）有生命周期，而函数组件（未使用 Hooks 的函数组件）是没有生命周期的**。

下面是具体的 class 与 Hooks 的**生命周期对应关系**：

- `constructor`：函数组件不需要构造函数，可以通过调用 `**useState** **来初始化 state**`。如果计算的代价比较昂贵，也可以传一个函数给 `useState`。

```
const [num, UpdateNum] = useState(0)
```

- `getDerivedStateFromProps`：一般情况下，我们不需要使用它，可以在**渲染过程中更新 state**，以达到实现 `getDerivedStateFromProps` 的目的。

```
function ScrollView({row}) {
  let [isScrollingDown, setIsScrollingDown] = useState(false);
  let [prevRow, setPrevRow] = useState(null);
  if (row !== prevRow) {
    // Row 自上次渲染以来发生过改变。更新 isScrollingDown。
    setIsScrollingDown(prevRow !== null && row > prevRow);
    setPrevRow(row);
  }
  return `Scrolling down: ${isScrollingDown}`;
}
```

React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。

- `shouldComponentUpdate`：可以用 `**React.memo**` 包裹一个组件来对它的 `props` 进行浅比较

```
const Button = React.memo((props) => {
  // 具体的组件
});
```

注意：` **React.memo** **等效于** ``**PureComponent** `，它只浅比较 props。这里也可以使用 `useMemo` 优化每一个节点。

- `render`：这是函数组件体本身。
- `componentDidMount`, `componentDidUpdate`： `useLayoutEffect` 与它们两的调用阶段是一样的。但是，我们推荐你**一开始先用 useEffect**，只有当它出问题的时候再尝试使用 `useLayoutEffect`。`useEffect` 可以表达所有这些的组合。

```
// componentDidMount
useEffect(()=>{
  // 需要在 componentDidMount 执行的内容
}, [])
useEffect(() => {
  // 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容
  document.title = `You clicked ${count} times`;
  return () => {
    // 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）
    // 以及 componentWillUnmount 执行的内容
  } // 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关
}, [count]); // 仅在 count 更改时更新
```

**请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便**

- `componentWillUnmount`：相当于 `useEffect `里面返回的 `cleanup` 函数

```
// componentDidMount/componentWillUnmount
useEffect(()=>{
  // 需要在 componentDidMount 执行的内容
  return function cleanup() {
    // 需要在 componentWillUnmount 执行的内容
  }
}, [])
```

- `componentDidCatch` and `getDerivedStateFromError`：目前**还没有**这些方法的 Hook 等价写法，但很快会加上。

| **class 组件**           | **Hooks 组件**            |
| ------------------------ | ------------------------- |
| constructor              | useState                  |
| getDerivedStateFromProps | useState 里面 update 函数 |
| shouldComponentUpdate    | useMemo                   |
| render                   | 函数本身                  |
| componentDidMount        | useEffect                 |
| componentDidUpdate       | useEffect                 |
| componentWillUnmount     | useEffect 里面返回的函数  |
| componentDidCatch        | 无                        |
| getDerivedStateFromError | 无                        |

### 18 常见的 hook

#### （1).useState

在函数组件中，可以使用 useState 来定义函数组件的状态。

- 引入
- 接收一个参数作为初始值
- 返回一个数组，第一个值为状态，第二个值为改变状态的函数

看一下同样的功能实现，函数组件的 useState 的代码实现如下。相同的功能，用函数组件的 useState 的写法是不是方便多了呢？接下来我们继续学习另外的 hooks

```javascript
import React, { useState } from "react";

function StateFunction() {
  const [name, setName] = useState("函数");
  //     类名，修改函数名            初始值

  return (
    <div onClick={() => setName("我使用hooks变成这样了")}>
      // setName也可以写入方法，如setName（ val => val+'xxxx' ）
      这是一个函数式组件————{name}
    </div>
  );
}

export default StateFunction;
```

#### （2).useEffect

useEffect 又称副作用 hooks。作用：给没有生命周期的组件，添加结束渲染的信号。执行时机：在渲染结束之后执行

什么是副作用？

副作用 ( side effect ): 数据获取，数据订阅，以及手动更改 React 组件中的 DOM 都属于副作用因为我们渲染出的页面都是静态的，任何在其之后的操作都会对他产生影响，所以称之为副作用

使用：

- 第一个参数，接收一个函数作为参数
- 第二个参数，接收【依赖列表】，只有依赖更新时，才会执行函数
- 返回一个函数，先执行返回函数，再执行参数函数

- 不接受第二个参数的情况下 如果不接受第二个参数，那么在第一次渲染完成之后和每次更新渲染页面的时候，都会调用 useEffect 的回调函数，所以你要考虑好使用场景。

  ```javascript
  import React, { useEffect, useState } from "react";

  function StateFunction() {
    const [num, setNum] = useState(0);

    useEffect(() => {
      console.log("2222函数式组件结束渲染");
    });

    return (
      <div onClick={() => setNum((num) => num + 1)}>
        这是一个函数式组件————{num}
      </div>
    );
  }
  ```

  - 接受第二个参数的情况下

  ```javascript
  useEffect(() => {
    console.log("2222函数式组件结束渲染");
  }, []);
  //	改变useEffect第二个参数，其余代码同上
  ```

  在这，我们可以对第二个参数传入一个数组，这个数组表示的是更新执行所依赖的列表，只有依赖列表改变时（当数组中的任意一项变化的时候，useEffect 会被重新执行 ），才会触发回调函数

  传入的为空数组[]，那么即告诉 useEffect 不依赖于 state、props 中的任意值，useEffect 就只会运行一次，常用场景为页面获取数据的方法可以写入此处进行调用，以获取页面初始数据 传入一个值构建的数组、或者多个值构建的数组，如[num]、[num,val]，上述代码变更为如下。那么此时只有当数组中的值（任意一项即可）改变时，才会重新触发回调函数

  ```javascript
  useEffect(() => {
    console.log("2222函数式组件结束渲染");
  }, [num]);

  useEffect(() => {
    console.log("2222函数式组件结束渲染");
  }, [num, val]);
  //	改变useEffect第二个参数，其余代码同上
  ```

- 清除副作用上面写的都是一些不需要清除的副作用，只是回调触发一些简单的方法，但是有一些副作用是需要清除的。例如绑定一些 DOM 事件，在这种情况下，清除工作是非常重要的，可以防止引起内存泄露，例如下面给出的代码对比

  ① 未清除副作用的情况下。此时第一次点击正常输出一次打印当前位置，而后每一次 useEffect 调用都会新绑定一个 updateMouse 方法，那么点击一次所触发绑定的方法越来越多，那么之后点击一次就会疯狂打印打印当前位置，这也就造成了页面性能、内存泄露等问题

  ```javascript
  const [positions, setPositions] = useState({ x: 0, y: 0 });

  useEffect(() => {
    console.log("2222函数式组件结束渲染");

    const updateMouse = (e) => {
      console.log("打印当前位置");
      setPositions({ x: e.clientX, y: e.clientY });
    };
    document.addEventListener("click", updateMouse);
  });

  return (
    <div>
      <p>x:{positions.x}</p>
      <p>y:{positions.y}</p>
    </div>
  );
  ```

  ② 清除副作用的情况下

  首次刷新或进入页面会先执行除 return 以外的内容，也就是会执行一个绑定的方法，然后将 updateMouse 方法绑定到 click 事件上

  并将改次 useEffect 中的事件清除返回出去，但是此时是并没有执行 return 中的内容的（重点注意）

  然后当你点击第一次的时候，就会打印设置当前鼠标页面坐标，然后先执行上一次 return 返回出去的内容，注意这里是执行上一次 return 中的清除事件绑定方法，然后执行该清除事件绑定方法，当然清除也是清除的上一个 useEffect 中的绑定事件

  然后再开始执行新的 useEffect 中的绑定事件方法，并再次将改次 useEffect 清除事件绑定的方法 return 返回出去，如此就形成了一个链式一样的过程

  当页面卸载的时候，会执行最后一次 return 返回出来的清除事件绑定的方法，这样也就保证了页面卸载的时候，移除了绑定添加的 DOM 事件方法

  ```javascript
  useEffect(() => {
    console.log("2222函数式组件结束渲染");
    const updateMouse = (e) => {
      console.log("打印当前位置");
      setPositions({ x: e.clientX, y: e.clientY });
    };
    document.addEventListener("click", updateMouse); //  添加绑定方法事件(要修改依赖，绑定到依赖上)

    return () => {
      //  在每次执行useEffect之前都会执行上一次return中内容
      document.removeEventListener("click", updateMouse);
      //  移除绑定方法事件(要修改依赖，绑定到依赖上)
      console.log("1111销毁");
    };
  });
  ```

- useEffect 中的异步每个 effect 函数都属于一次特定的渲染：

  ①useEffect 调度不会阻塞浏览器更新屏幕<异步> ② 每次重新渲染都会生成新的 effect，替换掉之前的，确保 effect 中获取的值是最新的，不用担心过期。如下，设置的 3000 毫秒内连续点击三次，那么将会一共打印 4 次，分别是 0、1、2、3，0 是第一次渲染结束之后自动触发的，剩下 1、2、3 则是点击三次每次触发时的 count 值

  ```javascript
  function Counter() {
    const [count, setCount] = useState(0);

    useEffect(() => {
      setTimeout(() => {
        console.log(`${count}`);
      }, 3000);
    });

    return (
      <div>
        <p>你点击了{count}次</p>
        <button onClick={() => setCount(count + 1)}>点击我</button>
      </div>
    );
  }
  ```

#### （3).useLayoutEffect

一般将 useLayoutEffect 称为有 DOM 操作的副作用 hooks。作用是在 DOM 更新完成之后执行某个操作。执行时机：在 DOM 更新之后执行与 useEffect 对比

相同点

1.第一个参数，接收一个函数作为参数 2.第二个参数，接收【依赖列表】，只有依赖更新时，才会执行函数 3.返回一个函数，先执行返回函数，再执行参数函数

不同点

执行时机不同。useLayoutEffect 在 DOM 更新之后执行；useEffect 在 render 渲染结束后执行。执行示例代码会发现 useLayoutEffect 永远比 useEffect 先执行，这是因为 DOM 更新之后，渲染才结束或者渲染还会结束

```javascript
const [num, setNum] = useState(0);
//在类组件中用componentWillMount生命周期来实现
useLayoutEffect(() => {
  console.log("useLayoutEfffect");
  //	也可以在此进行事件绑定
  return () => {
    //	也可以在此进行事件绑定移除
    console.log(1);
  };
}, [num]);

useEffect(() => {
  console.log("useEffect");
}, [num]);

return (
  <div onClick={() => setNum((num) => num + 1)}>
    这是一个函数式组件————{num}
  </div>
);
```

#### （4) useMemo

使用 useMemo 可以传递一个创建函数和依赖项，创建函数会需要返回一个值，只有在依赖项发生改变的时候，才会重新调用此函数，返回一个新的值。简单来说，作用是让组件中的函数跟随状态更新（即优化函数组件中的功能函数）。

使用：

1.接收一个函数作为参数 2.同样接收第二个参数作为依赖列表（可以与 useEffect、useLayoutEffect 进行对比学习） 3.返回的是一个值。返回值可以是任何，函数、对象等都可以

- 复杂计算逻辑优化使用场景

未优化前代码如下。当我们点击 div 区域时，此时触发的 setAge，改变的是 age，跟 getDoubleNum 方法其实是不相关的，但是如果你看下控制台，能看到打印了多次获取双倍 Num，说明该方法不断被触发，其实是没必要触发的。如果方法内计算量大、对性能是有一定影响的，所以需要进行优化

```javascript
const [num, setNum] = useState(1);
const [age, setAge] = useState(18);

function getDoubleNum() {
  console.log(`获取双倍Num${num}`);
  return 2 * num; //	假设为复杂计算逻辑
}

return (
  <div
    onClick={() => {
      setAge((age) => age + 1);
    }}
  >
    <br></br>
    这是一个函数式组件————{getDoubleNum()}
    <br></br>
    age的值为————{age}
    <br></br>
  </div>
);
```

使用 useMemo 优化后代码如下。此时 getDoubleNum 方法是接收一个返回的值，所以要注意注释里所写的，括号是去掉了的。使用 useMemo 后，再点击 div 区域改变 age 的值，此时执行返回的 return 2\*num 以及打印只有在 num 更新时才会去执行，然后返回值给到 getDoubleNum 再渲染到视图上，这样就减少了不必要的计算达到优化的作用

```javascript
const [num, setNum] = useState(1);
const [age, setAge] = useState(18);

const getDoubleNum = useMemo(() => {
  console.log(`获取双倍Num${num}`);
  return 2 * num; //	假设为复杂计算逻辑
}, [num]);

return (
  <div
    onClick={() => {
      setAge((age) => age + 1);
    }}
  >
    <br></br>
    这是一个函数式组件————num：{getDoubleNum} // 注意这里没括号，因为是返回值
    <br></br>
    age的值为————{age}
    <br></br>
  </div>
);
```

- 父子组件重复渲染问题优化使用场景

未优化前代码如下。子组件包裹一个 memo，但是包裹了还是会重新渲染, 为什么呢？因为我们定义的 info 是 const 定义的一个局部变量,每次重新渲染都是重新定义一个新的 info，然后子组件进行浅层比较时候，info 永远是不一样的，所以就会重新渲染。如果子组件比较复杂的情况下，那么就会对页面性能产生影响

```javascript
const Child = memo(() => {
  console.log("我是子组件");
  return <p>我是子组件</p>;
});

function Parent() {
  const [show, setShow] = useState(true);

  const info = {
    name: "Even",
    age: 22,
  };

  return (
    <div>
      <Child info={info} />
      <button onClick={() => setShow(!show)}>点击更新状态</button>
    </div>
  );
}
```

使用 useMemo 后代码如下（只给出修改代码，其它代码同上例子）。这样子优化后，子组件只会在初始化状态时渲染一次，当我们点击按钮时，因为 info 其包裹的 useMemo 依赖并没有改变，返回值是同一个值，所以不会造成子组件重新渲染。 const info = useMemo( () => { return { name: 'Even', age: 22 } },[])

#### （5） useCallback

useMemo 讲完我们来讲一个跟其很相似的叫 useCallback，作用也是让某些操作、方法跟随状态的更新而去执行。与 useMemo 对比。

可以简单这样看作，useMemo(() => Fn,deps)相当于 useCallback(Fn,deps) 不同点： useCallback 是对传过来的回调函数优化，返回的是一个函数；useMemo 返回值可以是任何，函数，对象等都可以相同点：在使用方法上，useMemo 与 useCallback 相同。接收一个函数作为参数，也同样接收第二个参数作为依赖列表

- 为何说 useCallback 缓存的是一个函数（重要区别）

useCallback 虽然与 useMemo 相似，但其返回及缓存的是一个函数，对比以下示例代码。先说 ①②③ 三种情况的对比

当 ① 情况时，只会打印一次获取双倍 Num1，也就是首次渲染的打印，之后再点击 div 区域改变 age 的值都与其无关，所以不会执行。因为 getDoubleNum 已经获得了 useMemo 中传入的函数执行后返回的值了，获取之后，便将其缓存下来了

当 ② 情况时，首次渲染会打印一次获取双倍 Num1，然后每点击一次都会打印获取双倍 Num1，这是为什么呢？不是说 useCallback 也有缓存的功能吗？这是因为我们前面提到的，useCallback 返回的是一个函数。因为 useCallback 中的函数是在当前组件内定义的，组件重新渲染，它自然也会重新渲染，这又会有同学说了，可是这也不能说明它缓存的是一个函数啊。那么你可以先看看 ③ 的依赖为[]情况时，那么你就能明白了。所以说复杂计算逻辑的场景不适合使用 useCallback 来缓存，因为传入的函数内容会不断执行。

当 ③ 情况时，我们结合 ②③ 处标记代码，set 只能存入唯一值，我们观察打印的 set 的长度

当 useCallback 依赖为空[]时，我们连续多次点击 div 区域，虽然 useCallback 中的内容会不断执行，但是我们可以看到打印出来的 set 的长度一直都是 2，这就是因为它不断将同一个函数添加进 set，所以 set 的长度不变而当 useCallback 的依赖为[num]时，我们连续多次点击 div 区域，可以看到打印出来的 set 在不断累加，1、2、3、4、5、6...。因为 num 在改变，所以每一次缓存的函数都是一个新的函数，所以添加进 set 的函数是不一样的，所以 set 的长度点一次加一次

```javascript
const set = new Set();
export default function StateFunction() {
  const [num, setNum] = useState(1);
  const [age, setAge] = useState(18);

  const getDoubleNum = useMemo(() => {
    console.log(`获取双倍Num${num}`);
    return 2 * num; //	①假设为复杂计算逻辑
  }, []);

  const getDoubleNum = useCallback(() => {
    console.log(`获取双倍Num${num}`);
    return 2 * num; //	②假设为复杂计算逻辑
  }, []);

  set.add(getDoubleNum()); //	③注意set打印的长度变化（设置Callback的依赖为[]、[num]进行对比）
  console.log("set.size：", set.size);

  return (
    <div
      onClick={() => {
        setNum((num) => num + 1);
      }}
    >
      <br></br>
      这是一个函数式组件————num：{getDoubleNum} //①useMemo情况下
      这是一个函数式组件————num：
      {getDoubleNum()} //②useCallback情况下
      <br></br>
      age的值为————{age}
      <br></br>
    </div>
  );
}
```

- useCallback 适用场景可以对父子组件传参渲染的问题进行优化。简单来说就是，父组件的传入函数不更新，就不会触发子组件的函数重新执行

通常而言，父组件更新了，那么子组件也会更新。但是如果父组件传入子组件的内容不变，那么子组件某些操作（某些操作是指需要跟随传入内容的改变而同步进行的操作）是没必要执行的，这会影响页面性能，所以我们可以对这情况进行优化。

例如示例代码，我们将 getDoubleNum 传入子组件，此时点击 div 区域改变的是 num 的值，我们使用父组件 useCallback 配合子组件的 useEffect 来优化，只有当父组件的 num 改变导致传入子组件的 getDoubleNum 改变的时候，我们才会执行子组件某些需要更新的操作，这样就可以避免子组件一些没必要的更新操作反复执行而影响页面性能

```javascript
function Parent() {
  const [num, setNum] = useState(1);
  const [age, setAge] = useState(18);

  const getDoubleNum = useCallback(() => {
    console.log(`获取双倍Num${num}`);
    return 2 * num;
  }, [num]);

  return (
    <div
      onClick={() => {
        setNum((num) => num + 1);
      }}
    >
      这是一个函数式组件————num:{getDoubleNum()}
      <br></br>
      age的值为————age:{age}
      <br></br>
      set.size:{set.size}
      <Child callback={getDoubleNum()}></Child>
    </div>
  );
}

function Child(props) {
  useEffect(() => {
    console.log("callback更新了"); //这里代表的是需要跟随传入内容的改变而同步进行的操作
  }, [props.callback]);

  return <div>子组件的getDoubleNum{props.callback}</div>;
}
```

#### （6） useRef

简单来说 useRef 就是返回一个子元素索引，此索引在整个生命周期中保持不变。作用也就是：长久保存数据。注意事项，保存的对象发生改变，不通知。属性变更不会重新渲染

未使用 useRef，如果我们有这样一个需求如下，需要当某个定时器自增的值达到限制条件后就清除该定时器，如下代码。此时以下的代码其实是没有办法完成给出的需求的，当 num 大于 10 后，会发现不停的打印大于 10 了，清除定时器，而其实是定时器没有清除掉的，所以会一直执行这两个打印内容，但是会发现打印出来的 timer 显示 undefined，这是为什么呢？因为我们每次渲染都是通过 setInterval 重新返回的 timer，timer 也在更新，也就丢失了 timer 这个数据，导致无法准确清除某个需要清除的定时器

```javascript
const [num, setNum] = useState(0);

let timer;
useEffect(() => {
  timer = setInterval(() => {
    setNum((num) => num + 1);
  }, 400);
}, []);

useEffect(() => {
  if (num > 10) {
    console.log("大于10了，清除定时器");
    console.log("timer：", timer);
    //  因为每一个timer都是独立render的，所以获取不到
    clearTimeout(timer);
  }
}, [num]);

return <div>这是一个函数式组件————num:{num}</div>;
```

使用 useRef 后，代码如下。我们可以看到 num 自增到 11 后就打印了一次大于 10 了，清除定时器以及 ref.current 1，然后就停止自增了，因为定时器被清除了。ref 是一个对象，ref.current 存储了该定时器在整个生命周期中的 id 值，所以当清除定时器的时候，可以准确清除这个定时器

保存一个值，在整个生命周期中维持不变

```javascript
const [num, setNum] = useState(0);

const ref = useRef();
useEffect(() => {
  ref.current = setInterval(() => {
    setNum((num) => num + 1);
  }, 400);
  // ref.current = '111'
}, []);

useEffect(() => {
  if (num > 10) {
    console.log("大于10了，清除定时器");
    console.log("ref.current", ref.current);
    clearTimeout(ref.current);
  }
}, [num]);

return <div>这是一个函数式组件————num:{num}</div>;
```

重新赋值 ref.current 不会主动触发页面重新渲染。当我们将代码修改成下面这样，会在控制台打印发现 ref.current 的值打印为 111，但是页面视图上显示的还是空，这是因为 ref 保存的对象发生改变，不会主动通知，属性变更不会重新渲染

```javascript
const [num, setNum] = useState(0);

const ref = useRef();
useEffect(() => {
  ref.current = "111";
  console.log("ref.current", ref.current);
}, []);

return (
  <div>
    这是ref.current的值——ref.current:{ref.current}
    <br></br>
    这是一个函数式组件————num:{num}
  </div>
);
```

#### （7） useContext

useContext 是让子组件之间共享父组件传入的状态的。作用通俗地说是带着子组件去流浪。

未使用 useContext，我们有下列这样一个场景，我们父组件有传入一个值到不同的子组件中，示例给出的代码是 2 个这样的子组件，但是如果我需要添加的子组件特别多呢？总不能总是一个一个这样添加写入吧，而且如果传入的同一个变量名如果发生改变，还得一个个去改，所以我们可以用 useContext 优化一下代码

```javascript
function StateFunction() {
  const [num, setNum] = useState(1);

  return (
    <div>
      <button onClick={() => setNum((num) => num + 1)}>增加num的值+1</button>
      <br></br>
      这是一个函数式组件——num:{num}
      <Item1 num={num}></Item1>
      <Item2 num={num}></Item2>
      // ......
    </div>
  );
}

function Item1(props) {
  return <div>子组件1 num：{props.num}</div>;
}

function Item2(props) {
  return <div>子组件2 num：{props.num}</div>;
}
```

使用 useContext 优化后，代码如下，这样我们只需要在子组件中使用 useContext(Context 句柄)来获取数据即可，添加同类子组件时不需要再关注父组件中子组件定义时的 props 传入值，使用方法如下

需要引入 useContetx，createContext 两个内容通过 createContext 创建一个 context 句柄 Context.Provider 来确定数据共享范围通过 value 来分发内容在子组件中，通过 useContext(Context 句柄)来获取数据注意事项，上层数据发生改变，肯定会触发重新渲染（点击 button 按钮触发父组件更新传入的 num 值能看到子组件重新渲染）

```javascript
const Context = createContext(null);

function StateFunction() {
  const [num, setNum] = useState(1);

  return (
    <div>
      <button onClick={() => setNum((num) => num + 1)}>增加num的值+1</button>
      <br></br>
      这是一个函数式组件——num:{num}
      <Context.Provider value={num}>
        <Item3></Item3>
        <Item4></Item4>
      </Context.Provider>
    </div>
  );
}

function Item3() {
  const num = useContext(Context);

  return <div>子组件3: {num}</div>;
}

function Item4() {
  const num = useContext(Context);

  return <div>子组件4: {num + 2}</div>;
}
```

#### （8） useReducer

以前是只能在类组件中使用 Redux，现在我们可以通过 useReducer 在函数式组件中使用 Redux。作用是可以从状态管理的工具中获取到想要的状态。

如何使用 useReducer。Redux 必须要有的内容就是仓库 store 和管理者 reducer。而 useReducer 也是一样的，需要创建数据仓库 store 和管理者 reducer，即示例代码注释处。然后我们就可以通过 ① 处的定义一个数组获取状态和改变状态的动作，触发动作的时候需要传入 type 类型判断要触发 reducer 哪个动作，然后进行数据的修改。需要注意的地方是，在 reducer 中 return 的对象中，需要将 state 解构，否则状态就剩下一个 num 值了

```javascript
const store = {
  age: 18,
  num: 1,
}; //	数据仓库

const reducer = (state, action) => {
  switch (action.type) {
    case "add":
      return {
        ...state,
        num: action.num + 1,
      };

    default:
      return {
        ...state,
      };
  }
}; //	管理者

function StateFunction() {
  const [state, dispacth] = useReducer(reducer, store); //	①

  return (
    <div>
      <button
        onClick={() => {
          dispacth({
            type: "add",
            num: state.num,
          });
        }}
      >
        增加num的值+1
      </button>
      <br></br>
      这是一个函数式组件——num:{state.num}
    </div>
  );
}
```

### 19 React Hook 原理

React 是实现了组件的前端框架，它支持 class 和 function 两种形式的组件。
class 组件是通过继承模版类（Component、PureComponent）的方式开发新组件的，继承是 class 本身的特性，它支持设置 state，会在 state 改变后重新渲染，可以重写一些父类的方法，这些方法会在 React 组件渲染的不同阶段调用，叫做生命周期函数。
function 组件不能做继承，因为 function 本来就没这个特性，所以是提供了一些 api 供函数使用，这些 api 会在内部的一个数据结构上挂载一些函数和值，并执行相应的逻辑，通过这种方式实现了 state 和类似 class 组件的生命周期函数的功能，这种 api 就叫做 hooks。hooks 挂载数据的数据结构叫做 fiber。
在 v16 之前的 React 里，是直接递归遍历 vdom，通过 dom api 增删改 dom 的方式来渲染的。但当 vdom 过大，频繁调用 dom api 会比较耗时，而且递归又不能打断，所以有性能问题。
![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ceb7142750443a8d946203f8192109~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)
后来就引入了 fiber 架构，先把 vdom 树转成 fiber 链表，然后再渲染 fiber。
![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e058b34041ea4b9d88c2e3289abdd55d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)
<br>
每个节点都会有一个对应的 Fiber 对象，他的数据解构如下：

```
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;  // 就是ReactElement的`?typeof`
  this.type = null;         // 就是ReactElement的type
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.firstContextDependency = null;

  // ...others
}
```

在这里我们需要注意的是 this.memoizedState，这个 key 就是用来存储在上次渲染过程中最终获得的节点的 state 的，每次执行 render 方法之前，React 会计算出当前组件最新的 state 然后赋值给 class 的实例，再调用 render。

有这么一段代码：

```
function FunctionalComponent () {
  const [state1, setState1] = useState(1)
  const [state2, setState2] = useState(2)
  const [state3, setState3] = useState(3)
}
```

先来看一张图 <br>![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/5/166e20d92aa52108~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)  
在我们执行 functionalComponent 的时候，在第一次执行到 useState 的时候，他会对应 Fiber 对象上的 memoizedState，这个属性原来设计来是用来存储 ClassComponent 的 state 的，因为在 ClassComponent 中 state 是一整个对象，所以可以和 memoizedState 一一对应。
但是在 Hooks 中，React 并不知道我们调用了几次 useState，所以在保存 state 这件事情上，React 想出了一个比较有意思的方案，那就是调用 useState 后设置在 memoizedState 上的对象长这样：

```
{
  baseState,
  next,
  baseUpdate,
  queue,
  memoizedState
}
```

我们叫他 Hook 对象。这里面我们最需要关心的是 memoizedState 和 next，memoizedState 是用来记录这个 useState 应该返回的结果的，而 next 指向的是下一次 useState 对应的`Hook 对象。
也就是说：

```
hook1 => Fiber.memoizedState
state1 === hook1.memoizedState
hook1.next => hook2
state2 === hook2.memoizedState
hook2.next => hook3
state3 === hook2.memoizedState
```

每个在 FunctionalComponent 中调用的 useState 都会有一个对应的 Hook 对象，他们按照执行的顺序以类似链表的数据格式存放在 Fiber.memoizedState 上
重点来了：就是因为是以这种方式进行 state 的存储，所以 useState（包括其他的 Hooks）都必须在 FunctionalComponent 的根作用域中声明，也就是不能在 if 或者循环中声明，比如

```javascript
if (something) {
  const [state1] = useState(1)
}

// or

for (something) {
  const [state2] = useState(2)
}
```

最主要的原因就是你不能确保这些条件语句每次执行的次数是一样的，也就是说如果第一次我们创建了 state1 => hook1, state2 => hook2, state3 => hook3 这样的对应关系之后，下一次执行因为 something 条件没达成，导致 useState(1)没有执行，那么运行 useState(2)的时候，拿到的 hook 对象是 state1 的，那么整个逻辑就乱套了，所以这个条件是必须要遵守的！
setState
上面讲了 Hooks 中 state 是如何保存的，那么接下去来讲讲如何更新 state
我们调用的调用 useState 返回的方法是这样的：

```javascript
var dispatch = (queue.dispatch = dispatchAction.bind(
  null,
  currentlyRenderingFiber$1,
  queue
));
return [workInProgressHook.memoizedState, dispatch];
调用这个方法会创建一个update;
var update = {
  expirationTime: _expirationTime,
  action: action,
  callback: callback !== undefined ? callback : null,
  next: null,
};
```

这里的 action 是我们调用 setState1 传入的值，而这个 update 会被加入到 queue 上，因为可能存在一次性调用多次 setState1 的清空（跟 React 的 batchUpdate 有关，以后有机会讲。）
在收集完这所有 update 之后，会调度一次 React 的更新，在更新的过程中，肯定会执行到我们的 FunctionalComponent，那么就会执行到对应的 useState，然后我们就拿到了 Hook 对象，他保存了 queue 对象表示有哪些更新存在，然后依次进行更新，拿到最新的 state 保存在 memoizedState 上，并且返回，最终达到了 setState 的效果。

### 20 React setState 调用的原理

![image.png](https://cdn.nlark.com/yuque/0/2021/png/1500604/1611908814278-be06f25f-ee6f-44d5-93f1-c0a24eecd456.png)

具体的执行过程如下（源码级解析）：

- 首先调用了`setState` 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；

```
ReactComponent.prototype.setState = function (partialState, callback) {
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};
```

- `enqueueSetState` 方法将新的 `state` 放进组件的状态队列里，并调用 `enqueueUpdate` 来处理将要更新的实例对象；

```javascript
enqueueSetState: function (publicInstance, partialState) {
  // 根据 this 拿到对应的组件实例
  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
  // 这个 queue 对应的就是一个组件实例的 state 数组
  var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
  queue.push(partialState);
  //  enqueueUpdate 用来处理当前的组件实例
  enqueueUpdate(internalInstance);
}
```

- 在 `enqueueUpdate` 方法中引出了一个关键的对象——`batchingStrategy`，该对象所具备的`isBatchingUpdates` 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 `batchedUpdates` 方法来直接发起更新流程。由此可以推测，`batchingStrategy` 或许正是 React 内部专门用于管控批量更新的对象。

```javascript
function enqueueUpdate(component) {
  ensureInjected();
  // 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段
  if (!batchingStrategy.isBatchingUpdates) {
    // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }
  // 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”
  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}
```

**注意：**`batchingStrategy` 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 `isBatchingUpdates` 变量，`isBatchingUpdates` 的初始值是 `false`，意味着“当前并未进行任何批量更新操作”。每当 React 调用 `batchedUpdate` 去执行更新动作时，会先把这个锁给“锁上”（置为 `true`），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 `dirtyComponents` 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。

### 21 组件通讯

React 组件间通信常见的几种情况:

- **⽗组件向⼦组件通讯**: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯
- **⼦组件向⽗组件通讯**: props+回调的⽅式，⽗组件向⼦组件传递 props 进⾏通讯，此 props 为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中
- **兄弟组件通信**: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信
- **跨层级通信**: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过
- **发布订阅模式**: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊ event 模块进⾏通信
- **全局状态管理⼯具**: 借助 Redux 或者 Mobx 等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼ Store,并根据不同的事件产⽣新的状态

#### （1）. 父子组件的通信方式？

**父组件向子组件通信**：父组件通过 props 向子组件传递需要的信息。

```javascript
// 子组件: Child
const Child = (props) => {
  return <p>{props.name}</p>;
};
// 父组件 Parent
const Parent = () => {
  return <Child name="react"></Child>;
};
```

**子组件向父组件通信**：: props+回调的方式。

```javascript
// 子组件: Child
const Child = (props) => {
  const cb = (msg) => {
    return () => {
      props.callback(msg);
    };
  };
  return <button onClick={cb("你好!")}>你好</button>;
};
// 父组件 Parent
class Parent extends Component {
  callback(msg) {
    console.log(msg);
  }
  render() {
    return <Child callback={this.callback.bind(this)}></Child>;
  }
}
```

#### （2）. 跨级组件的通信方式？

父组件向子组件的子组件通信，向更深层子组件通信：

- 使用 props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是中间组件自己需要的。
- 使用 context，context 相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用 context 实现。

```javascript
// context方式实现跨级组件通信
// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据
const BatteryContext = createContext();
//  子组件的子组件
class GrandChild extends Component {
  render() {
    return (
      <BatteryContext.Consumer>
        {(color) => <h1 style={{ color: color }}>我是红色的:{color}</h1>}
      </BatteryContext.Consumer>
    );
  }
}
//  子组件
const Child = () => {
  return <GrandChild />;
};
// 父组件
class Parent extends Component {
  state = {
    color: "red",
  };
  render() {
    const { color } = this.state;
    return (
      <BatteryContext.Provider value={color}>
        <Child></Child>
      </BatteryContext.Provider>
    );
  }
}
```

#### （3）. 非嵌套关系组件的通信方式？

即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。

- 可以使用自定义事件通信（发布订阅模式）
- 可以通过 redux 等进行全局状态管理
- 如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。

### 22. React-Router 的实现原理是什么？

客户端路由实现的思想：

- 基于 hash 的路由：通过监听`hashchange`事件，感知 hash 的变化

- - 改变 hash 可以直接通过 location.hash=xxx

- 基于 H5 history 路由：

- - 改变 url 可以通过 history.pushState 和 resplaceState 等，会将 URL 压入堆栈，同时能够应用 `history.go()` 等 API
  - 监听 url 的变化可以通过自定义事件触发实现

react-router 实现的思想：

- 基于 `history` 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知
- 通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render

### 23. 如何配置 React-Router 实现路由切换

**（1）使用 `<Route>` 组件**

路由匹配是通过比较 `<Route>` 的 path 属性和当前地址的 pathname 来实现的。当一个 `<Route>`匹配成功时，它将渲染其内容，当它不匹配时就会渲染 null。没有路径的 `<Route>` 将始终被匹配。

```
// when location = { pathname: '/about' }
<Route path='/about' component={About}/> // renders <About/>
<Route path='/contact' component={Contact}/> // renders null
<Route component={Always}/> // renders <Always/>
```

**（2）结合使用 `<Switch>` 组件和 `<Route>` 组件**

`<Switch>` 用于将 `<Route>`分组。

```
<Switch>
    <Route exact path="/" component={Home} />
    <Route path="/about" component={About} />
    <Route path="/contact" component={Contact} />
</Switch>
```

`<Switch>` 不是分组 `<Route>` 所必须的，但他通常很有用。 一个 `<Switch>` 会遍历其所有的子 `<Route>`元素，并仅渲染与当前地址匹配的第一个元素。

**（3）使用 `<Link>`、 `<NavLink>`、`<Redirect>` 组件**

`<Link> `组件来在你的应用程序中创建链接。无论你在何处渲染一个 `<Link> `，都会在应用程序的 HTML 中渲染锚（`<a>`）。

```
<Link to="/">Home</Link>
// <a href='/'>Home</a>
```

`<NavLink>` 是一种特殊类型的 `<Link>` 当它的 to 属性与当前地址匹配时，可以将其定义为"活跃的"。

```
// location = { pathname: '/react' }
<NavLink to="/react" activeClassName="hurray">
    React
</NavLink>
// <a href='/react' className='hurray'>React</a>
```

当我们想强制导航时，可以渲染一个`<Redirect>`，当一个`<Redirect>`渲染时，它将使用它的 to 属性进行定向。

### 24. React-Router 怎么设置重定向？

使用`<Redirect>`组件实现路由的重定向：

```
<Switch>
  <Redirect from='/users/:id' to='/users/profile/:id'/>
  <Route path='/users/profile/:id' component={Profile}/>
</Switch>
```

当请求 `/users/:id` 被重定向去 `'/users/profile/:id'`：

- 属性 `from: string`：需要匹配的将要被重定向路径。
- 属性 `to: string`：重定向的 URL 字符串
- 属性 `to: object`：重定向的 location 对象
- 属性 `push: bool`：若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。

### 25. React-Router 如何获取 URL 的参数和历史对象？

**（1）获取 URL 的参数**

- **get 传值**

路由配置还是普通的配置，如：`'admin'`，传参方式如：`'admin?id='1111''`。通过`this.props.location.search`获取 url 获取到一个字符串`'?id='1111'`

可以用 url，qs，querystring，浏览器提供的 api URLSearchParams 对象或者自己封装的方法去解析出 id 的值。

- **动态路由传值**

路由需要配置成动态路由：如`path='/admin/:id'`，传参方式，如`'admin/111'`。通过`this.props.match.params.id` 取得 url 中的动态路由 id 部分的值，除此之外还可以通过`useParams（Hooks）`来获取

- **通过 query 或 state 传值**

传参方式如：在 Link 组件的 to 属性中可以传递对象`{pathname:'/admin',query:'111',state:'111'};`。通过`this.props.location.state`或`this.props.location.query`来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。

**（2）获取历史对象**

- 如果 React >= 16.8 时可以使用 React Router 中提供的 Hooks

```
import { useHistory } from "react-router-dom";
let history = useHistory();
```

2.使用 this.props.history 获取历史对象

```
let history = this.props.history;
```


### 26. React-Router 的路由有几种模式？

React-Router 支持使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则， react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 UI 和 URL 同步：

- BrowserRouter 创建的 URL 格式：http://xxx.com/path
- HashRouter 创建的 URL 格式：http://xxx.com/#/path

**（1）BrowserRouter**

它使用 HTML5 提供的 history API（pushState、replaceState 和 popstate 事件）来保持 UI 和 URL 的同步。由此可以看出，**BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的：**

```
<BrowserRouter
    basename={string}
    forceRefresh={bool}
    getUserConfirmation={func}
    keyLength={number}
/>
```

**其中的属性如下：**

- basename 所有路由的基准 URL。basename 的正确格式是前面有一个前导斜杠，但不能有尾部斜杠；

```
<BrowserRouter basename="/calendar">
    <Link to="/today" />
</BrowserRouter>
```

等同于

```
<a href="/calendar/today" />
```

- forceRefresh 如果为 true，在导航的过程中整个页面将会刷新。一般情况下，只有在不支持 HTML5 history API 的浏览器中使用此功能；
- getUserConfirmation 用于确认导航的函数，默认使用 window.confirm。例如，当从 /a 导航至 /b 时，会使用默认的 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理；

```
// 这是默认的确认函数
const getConfirmation = (message, callback) => {
  const allowTransition = window.confirm(message);
  callback(allowTransition);
}
<BrowserRouter getUserConfirmation={getConfirmation} />
```

> 需要配合`<Prompt>` 一起使用。

- KeyLength 用来设置 Location.Key 的长度。

**（2）HashRouter**

使用 URL 的 hash 部分（即 window.location.hash）来保持 UI 和 URL 的同步。由此可以看出，**HashRouter 是通过 URL 的 hash 属性来控制路由跳转的：**

```
<HashRouter
    basename={string}
    getUserConfirmation={func}
    hashType={string}
/>
```

**其中的参数如下**：

- basename, getUserConfirmation 和 `BrowserRouter` 功能一样；
- hashType window.location.hash 使用的 hash 类型，有如下几种：

- - slash - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops；
  - noslash - 后面没有斜杠，例如 # 和 #sunshine/lollipops；
  - hashbang - Google 风格的 ajax crawlable，例如 #!/ 和 #!/sunshine/lollipops。


### 27. React diff 算法的原理是什么？

为了避免大量，频繁操作 DOM，React 引入了虚拟 DOM，在 16 版本之后又用 fiber 树替代了虚拟 DOM 树。但是当发生更新时，如何高效将老的树替换成新的树，这是个难题，按照一些通用的算法解决方案，即使使用最优的算法，算法的复杂度依然为 O(n 3 )，n 是元素的数量。
这样的结果不是 React 想要的，基于这样的背景，React 团队有了更大胆的想法，既然替换树的代价这么大，那我选择重新建一棵树，没错，简单粗暴。

当对比两棵树时，首先会比较两棵树的根节点。如果根节点为不同类型的元素，React 不会考虑替换根节点再往下递归比对，而是选择放弃这棵树，重新建一棵，在向下递归也是一样的，遇到节点类型不同，就会删除这个节点和下面的所有子节点，然后重新构建；

当对比两个相同类型的组件元素时：

class 组件实例保持不变（所以不同的渲染时 state 是一致的），仅更新组件实例的 props。
函数组件会重新执行（所以需要 hooks 记录状态）。

当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性；

引入 key，开发者手动设置元素 key 值来标记元素，React 基于 key 对元素进行比对；

上面的几点就是 React 的 diff 算法的结果，好了，弄明白了 React 的 diff 算法都做了些什么，接下来看下 React 的 diff 算法是怎么做到这几点的。

- **beginWork 阶段**

  - **对比不同类型的元素**  
    伪代码如下

    ```
    if (child.elementType === element.type) {
        deleteRemainingChildren(returnFiber, child.sibling);

        // clone current fiber并替换pendingProps为当前的element.props
        var _existing3 = useFiber(child, element.props);

        _existing3.return = returnFiber;

        return _existing3;
    }
    else {
      // 删除之前的fiber
      deleteRemainingChildren(returnFiber, child);

      // 重新根据element创建fiber
      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);

      _created4.return = returnFiber;
      return _created4;
    }
    ```

    从上面的代码，第一行的判断语句 child.elementType === element.type，当 React 发现更新前后的元素类型不同时，根本不会考虑其他的，直接就把之前的 fiber 节点给干掉了，不用它了，自己重新根据新的 fiber 重新构建。

  - **对比相同类型的元素**  
    当两个元素类型相同时，React 出于性能的考量会考虑复用已有的 fiber，也就是保留 DOM 元素，但是会替换 fiber.pendingProps。因为我们的 DOM 元素的信息都记录在 props 上，React 直接将新的 props 替换老的 props。

    ```
    if (child.elementType === element.type) {
        deleteRemainingChildren(returnFiber, child.sibling);

        // clone current fiber并替换pendingProps为当前的element.props
        var _existing3 = useFiber(child, element.props);

        _existing3.return = returnFiber;

        return _existing3;
    }
    ```

    - **key 的使用**  
      很简单的代码，却有很大的功劳。React 会将新老节点的 key 值进行比较来确定新老节点是不是对应关系，如果是就更新，不是就返回 null 跳过。
      那什么情况下可能会返回 null 呢？
      答案是：

      插入新的节点；
      删除了节点；
      节点顺序有变动；

      ```
      {
          if (newChild.key === key) {
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, oldFiber, newChild.props.children, lanes, key);
            }

            return updateElement(returnFiber, oldFiber, newChild, lanes);
          } else {
            return null;
          }
        }
      ```

      当 newFiber 返回 null 会进下面的代码，这时 oldFiber 会通过下面的代码再次重置回上次的值，保证 key 的有效性，然后会跳出和 oldFiber 匹配 key 的循环。

      ```
      if (oldFiber.index > newIdx) {
          nextOldFiber = oldFiber;
          oldFiber = null;
      }
      if (newFiber === null) {
          if (oldFiber === null) {
            oldFiber = nextOldFiber;
          }
          break;
      }
      ```

      在跳出循环后，会去将剩下没有匹配成功的 oldFiber 以 key（没有 key，会使用 index）为键存储到 Map 结构中

      ```
      var existingChildren = mapRemainingChildren(returnFiber, oldFiber)
      ```

      在接下来， React 会从没有匹配成功 key 的地方遍历 newFiber 数组，然后从 oldFiber 的 Map 结构中去匹配剩下的 newFiber，做到最大程度的复用，能匹配就匹配（匹配成功后，会从 existingChildren 将其删除掉），不能匹配就是新增的，会创建一个对应的节点。

      ```
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);

        if (_newFiber2 !== null) {
          if (shouldTrackSideEffects) {
            if (_newFiber2.alternate !== null) {
              existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
            }
          }

          lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

          if (previousNewFiber === null) {
            resultingFirstChild = _newFiber2;
          } else {
            previousNewFiber.sibling = _newFiber2;
          }

          previousNewFiber = _newFiber2;
        }
      }
      ```

    - **子节点位置比较**  
      当 React 的一个父节点是相同类型元素，替换了了 props 后，会继续往下递归，每个子节点的更新方式和父节点的一样：

      比较元素类型是否相同；
      替换 proprs；

      值得注意的是，当有多个子节点时，可能会有增删节点，或者调换节点顺序的情况，这时候就需要考虑这些子节点位置有没有变化。

      ```
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;

          var current = newFiber.alternate;

          if (current !== null) {
            var oldIndex = current.index;

            if (oldIndex < lastPlacedIndex) {
              // 给fiber打上Placement标记，要移动
              newFiber.flags = Placement;
              return lastPlacedIndex;
            } else {
              // 和之前一样，在同一个位置
              return oldIndex;
            }
          } else {
            // 没有老节点的情况，说明这是一个插入操作
            newFiber.flags = Placement;
            return lastPlacedIndex;
          }
        }
      ```

    - **子节点更新完毕**  
      当子节点已经更新完了，如果还有老节点，会直接删除，不会考虑再做比对
      ```
      if (newIdx === newChildren.length) {
        deleteRemainingChildren(returnFiber, oldFiber);
        return resultingFirstChild;
      ```

- **completeWork 阶段**  
  之前的文章有讲过，在 completeWork 阶段会有个向上查找的过程，如果是更新，它会创建一个更新队列 updateQueue，更新的内容就是新老 props 进行 diff 后的结果。这里进行 diff 的代码实在太长，精简如下

  ```javascript
  function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
    {
      validatePropertiesInDevelopment(tag, nextRawProps);
    }

    var updatePayload = null;
    var lastProps;
    var nextProps;

    switch (tag) {
      case 'input':
        lastProps = getHostProps(domElement, lastRawProps);
        nextProps = getHostProps(domElement, nextRawProps);
        updatePayload = [];
        break;

      case 'option':
        ...  //和上面类似
        break;

      case 'select':
        ...  //和上面类似
        break;

      case 'textarea':
        ...  //和上面类似
        break;

      default:
        lastProps = lastRawProps;
        nextProps = nextRawProps;
        break;
    }

    assertValidProps(tag, nextProps);
    var propKey;
    var styleName;
    var styleUpdates = null;

    for (propKey in lastProps) {
      ...
    }

    for (propKey in nextProps) {
      ...
    }

    if (styleUpdates) {
      {
        validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
      }

      (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
    }

    return updatePayload;
  }
  ```

  在上面代码中，有区分表单和一般的 DOM 元素，因为表单可以保存用户交互状态，React 需要将表单的状态组装到 props 中，在下面主要是遍历 lastProps 和 nextProps，区分 prop 是 style, dangerouslySetInnerHTML, children 和其他一些属性进行不同的处理，主要是比较 lastProps 和 nextProps，将 nextProps 没有而 lastProps 上有的重置，nextProps 有且和 lastProps 不同的加到更新里去。

### 28. React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。

在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系。

注意事项：

- key 值一定要和具体的元素—一对应；
- 尽量不要用数组的 index 去作为 key；
- 不要在 render 的时候用随机数或者其他操作给元素加上不稳定的 key，这样造成的性能开销比不加 key 的情况下更糟糕。

### 29. 虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么

虚拟 DOM 相对原生的 DOM 不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 DOM 的操作无论如何都不可能比真实的 DOM 操作更快。在首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，虚拟 DOM 也会比 innerHTML 插入慢。它能保证性能下限，在真实 DOM 操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。

在整个 DOM 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验/研发效率。虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。**虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。**

### 30. React 与 Vue 的 diff 算法有何不同？

diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。

React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。

- 树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。
- 组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。
- 元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。

以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。

Vue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。

### 31. Redux 的理解以及原理和工作流程

**（1）是什么？**  
 React 是用于构建用户界面的，帮助我们解决渲染 DOM 的过程

而在整个应用中会存在很多个组件，每个组件的 state 是由自身进行管理，包括组件定义自身的 state、组件之间的通信通过 props 传递、使用 Context 实现数据共享

如果让每个组件都存储自身相关的状态，理论上来讲不会影响应用的运行，但在开发及后续维护阶段，我们将花费大量精力去查询状态的变化过程

这种情况下，如果将所有的状态进行集中管理，当需要更新状态的时候，仅需要对这个管理集中处理，而不用去关心状态是如何分发到每一个组件内部的

redux 就是一个实现上述集中管理的容器，遵循三大基本原则：

单一数据源
state 是只读的
使用纯函数来执行修改
注意的是，redux 并不是只应用在 react 中，还与其他界面库一起使用，如 Vue
redux 要求我们把数据都放在 store 公共存储空间

一个组件改变了 store 里的数据内容，其他组件就能感知到 store 的变化，再来取数据，从而间接的实现了这些数据传递的功能

工作流程图如下所示：
![img](https://static.vue-js.com/27b2e930-e56b-11eb-85f6-6fac77c0c9b3.png)

根据流程图，可以想象，React Components 是借书的用户， Action Creactor 是借书时说的话(借什么书)， Store 是图书馆管理员，Reducer 是记录本(借什么书，还什么书，在哪儿，需要查一下)， state 是书籍信息

整个流程就是借书的用户需要先存在，然后需要借书，需要一句话来描述借什么书，图书馆管理员听到后需要查一下记录本，了解图书的位置，最后图书馆管理员会把这本书给到这个借书人

转换为代码是，React Components 需要获取一些数据, 然后它就告知 Store 需要获取数据，这就是就是 Action Creactor , Store 接收到之后去 Reducer 查一下， Reducer 会告诉 Store 应该给这个组件什么数据

**（2）原理**

Redux 源码主要分为以下几个模块文件

- compose.js 提供从右到左进行函数式编程
- createStore.js 提供作为生成唯一 store 的函数
- combineReducers.js 提供合并多个 reducer 的函数，保证 store 的唯一性
- bindActionCreators.js 可以让开发者在不直接接触 dispacth 的前提下进行更改 state 的操作
- applyMiddleware.js 这个方法通过中间件来增强 dispatch 的功能

```
const actionTypes = {
    ADD: 'ADD',
    CHANGEINFO: 'CHANGEINFO',
}

const initState = {
    info: '初始化',
}

export default function initReducer(state=initState, action) {
    switch(action.type) {
        case actionTypes.CHANGEINFO:
            return {
                ...state,
                info: action.preload.info || '',
            }
        default:
            return { ...state };
    }
}

export default function createStore(reducer, initialState, middleFunc) {

    if (initialState && typeof initialState === 'function') {
        middleFunc = initialState;
        initialState = undefined;
    }

    let currentState = initialState;

    const listeners = [];

    if (middleFunc && typeof middleFunc === 'function') {
        // 封装dispatch
        return middleFunc(createStore)(reducer, initialState);
    }

    const getState = () => {
        return currentState;
    }

    const dispatch = (action) => {
        currentState = reducer(currentState, action);

        listeners.forEach(listener => {
            listener();
        })
    }

    const subscribe = (listener) => {
        listeners.push(listener);
    }

    return {
        getState,
        dispatch,
        subscribe
    }
}
```

**（3）工作流程**

- const store= createStore（fn）生成数据;
- action: {type: Symble('action01), payload:'payload' }定义行为;
- dispatch 发起 action：store.dispatch(doSomething('action001'));
- reducer：处理 action，返回新的 state;

通俗点解释：

- 首先，用户（通过 View）发出 Action，发出方式就用到了 dispatch 方法
- 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action，Reducer 会返回新的 State
- State—旦有变化，Store 就会调用监听函数，来更新 View

以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由 Reducers 来担任，store 只做存储，中间人，当 Reducers 的更新完成以后会通过 store 的订阅来通知 react component，组件把新的状态重新获取渲染，组件中也能主动发送 action，创建 action 后这个动作是不会执行的，所以要 dispatch 这个 action，让 store 通过 reducers 去做更新 React Component 就是 react 的每个组件。

### 32. Redux 中异步的请求怎么处理

可以在 componentDidmount 中直接进⾏请求⽆须借助 redux。但是在⼀定规模的项⽬中,上述⽅法很难进⾏异步流的管理,通常情况下我们会借助 redux 的异步中间件进⾏异步处理。redux 异步流中间件其实有很多，当下主流的异步中间件有两种 redux-thunk、redux-saga。

**（1）使用 react-thunk 中间件**

**redux-thunk**优点**:**

- 体积⼩: redux-thunk 的实现⽅式很简单,只有不到 20 ⾏代码
- 使⽤简单: redux-thunk 没有引⼊像 redux-saga 或者 redux-observable 额外的范式,上⼿简单

**redux-thunk**缺陷**:**

- 样板代码过多: 与 redux 本身⼀样,通常⼀个请求需要⼤量的代码,⽽且很多都是重复性质的
- 耦合严重: 异步操作与 redux 的 action 偶合在⼀起,不⽅便管理
- 功能孱弱: 有⼀些实际开发中常⽤的功能需要⾃⼰进⾏封装

使用步骤：

- 配置中间件，在 store 的创建中配置

```
import {createStore, applyMiddleware, compose} from 'redux';
import reducer from './reducer';
import thunk from 'redux-thunk'

// 设置调试工具
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;
// 设置中间件
const enhancer = composeEnhancers(
  applyMiddleware(thunk)
);

const store = createStore(reducer, enhancer);

export default store;
```

- 添加一个返回函数的 actionCreator，将异步请求逻辑放在里面

```
/**
  发送get请求，并生成相应action，更新store的函数
  @param url {string} 请求地址
  @param func {function} 真正需要生成的action对应的actionCreator
  @return {function}
*/
// dispatch为自动接收的store.dispatch函数
export const getHttpAction = (url, func) => (dispatch) => {
    axios.get(url).then(function(res){
        const action = func(res.data)
        dispatch(action)
    })
}
```

- 生成 action，并发送 action

```
componentDidMount(){
    var action = getHttpAction('/getData', getInitTodoItemAction)
    // 发送函数类型的action时，该action的函数体会自动执行
    store.dispatch(action)
}
```

**（2）使用 redux-saga 中间件**

**redux-saga**优点**:**

- 异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中
- action 摆脱 thunk function: dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满 “⿊魔法” thunk function
- 异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理
- 功能强⼤: redux-saga 提供了⼤量的 Saga 辅助函数和 Effect 创建器供开发者使⽤,开发者⽆须封装或者简单封装即可使⽤
- 灵活: redux-saga 可以将多个 Saga 可以串⾏/并⾏组合起来,形成⼀个⾮常实⽤的异步 flow
- 易测试，提供了各种 case 的测试⽅案，包括 mock task，分⽀覆盖等等

**redux-saga**缺陷**:**

- 额外的学习成本: redux-saga 不仅在使⽤难以理解的 generator function,⽽且有数⼗个 API,学习成本远超 redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与 redux-observable 不同,redux-observable 虽然也有额外学习成本但是背后是 rxjs 和⼀整套思想
- 体积庞⼤: 体积略⼤,代码近 2000 ⾏，min 版 25KB 左右
- 功能过剩: 实际上并发控制等功能很难⽤到,但是我们依然需要引⼊这些代码
- ts ⽀持不友好: yield ⽆法返回 TS 类型

redux-saga 可以捕获 action，然后执行一个函数，那么可以把异步代码放在这个函数中，使用步骤如下：

- 配置中间件

```
import {createStore, applyMiddleware, compose} from 'redux';
import reducer from './reducer';
import createSagaMiddleware from 'redux-saga'
import TodoListSaga from './sagas'

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;
const sagaMiddleware = createSagaMiddleware()

const enhancer = composeEnhancers(
  applyMiddleware(sagaMiddleware)
);

const store = createStore(reducer, enhancer);
sagaMiddleware.run(TodoListSaga)

export default store;
```

- 将异步请求放在 sagas.js 中

```
import {takeEvery, put} from 'redux-saga/effects'
import {initTodoList} from './actionCreator'
import {GET_INIT_ITEM} from './actionTypes'
import axios from 'axios'

function* func(){
    try{
        // 可以获取异步返回数据
        const res = yield axios.get('/getData')
        const action = initTodoList(res.data)
        // 将action发送到reducer
        yield put(action)
    }catch(e){
        console.log('网络请求失败')
    }
}

function* mySaga(){
    // 自动捕获GET_INIT_ITEM类型的action，并执行func
    yield takeEvery(GET_INIT_ITEM, func)
}

export default mySaga
```

- 发送 action

```
componentDidMount(){
  const action = getInitTodoItemAction()
  store.dispatch(action)
}
```

### 33. Redux 请求中间件如何处理并发

**使用 redux-Saga**

redux-saga 是一个管理 redux 应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将 react 中的同步操作与异步操作区分开来，以便于后期的管理与维护。 redux-saga 如何处理并发：

- **takeEvery**

可以让多个 saga 任务并行被 fork 执行。

```
import {
    fork,
    take
} from "redux-saga/effects"

const takeEvery = (pattern, saga, ...args) => fork(function*() {
    while (true) {
        const action = yield take(pattern)
        yield fork(saga, ...args.concat(action))
    }
})
```

- **takeLatest**

takeLatest 不允许多个 saga 任务并行地执行。一旦接收到新的发起的 action，它就会取消前面所有 fork 过的任务（如果这些任务还在执行的话）。

在处理 AJAX 请求的时候，如果只希望获取最后那个请求的响应， takeLatest 就会非常有用。

```
import {
    cancel,
    fork,
    take
} from "redux-saga/effects"

const takeLatest = (pattern, saga, ...args) => fork(function*() {
    let lastTask
    while (true) {
        const action = yield take(pattern)
        if (lastTask) {
            yield cancel(lastTask) // 如果任务已经结束，则 cancel 为空操作
        }
        lastTask = yield fork(saga, ...args.concat(action))
    }
})
```

### 34. mobox 和 redux 有什么区别？

**（1）共同点**

- 为了解决状态管理混乱，无法有效同步的问题统一维护管理应用状态;
- 某一状态只有一个可信数据来源（通常命名为 store，指状态容器）;
- 操作更新状态方式统一，并且可控（通常以 action 方式提供更新状态的途径）;
- 支持将 store 与 React 组件连接，如 react-redux，mobx- react;

**（2）区别**

Redux 更多的是遵循 Flux 模式的一种实现，是一个 JavaScript 库，它关注点主要是以下几方面 ∶

- Action∶ 一个 JavaScript 对象，描述动作相关信息，主要包含 type 属性和 payload 属性 ∶

​ o type∶ action 类型;

​ o payload∶ 负载数据;

- Reducer∶ 定义应用状态如何响应不同动作（action），如何更新状态;
- Store∶ 管理 action 和 reducer 及其关系的对象，主要提供以下功能 ∶

​ o 维护应用状态并支持访问状态(getState());

​ o 支持监听 action 的分发，更新状态(dispatch(action));

​ o 支持订阅 store 的变更(subscribe(listener));

- 异步流 ∶ 由于 Redux 所有对 store 状态的变更，都应该通过 action 触发，异步任务（通常都是业务或获取数据任务）也不例外，而为了不将业务或数据相关的任务混入 React 组件中，就需要使用其他框架配合管理异步任务流程，如 redux-thunk，redux-saga 等;

Mobx 是一个透明函数响应式编程的状态管理库，它使得状态管理简单可伸缩 ∶

- Action∶ 定义改变状态的动作函数，包括如何变更状态;
- Store∶ 集中管理模块状态（State）和动作(action)
- Derivation（衍生）∶ 从应用状态中派生而出，且没有任何其他影响的数据

**对比总结：**

- redux 将数据保存在单一的 store 中，mobx 将数据保存在分散的多个 store 中
- redux 使用 plain object 保存数据，需要手动处理变化后的操作;mobx 适用 observable 保存数据，数据变化后自动处理响应的操作
- redux 使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数;mobx 中的状态是可变的，可以直接对其进行修改
- mobx 相对来说比较简单，在其中有很多的抽象，mobx 更多的使用面向对象的编程思维;redux 会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用
- mobx 中有更多的抽象和封装，调试会比较困难，同时结果也难以预测;而 redux 提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易

### 35. 同时引用这三个库 react.js、react-dom.js 和 babel.js 它们都有什么作用？

- react：包含 react 所必须的核心代码
- react-dom：react 渲染在不同平台所需要的核心代码
- babel：将 jsx 转换成 React 代码的工具

### 36. 对 React SSR 的理解

服务端渲染是数据与模版组成的 html，即 HTML = 数据 ＋ 模版。将组件或页面通过服务器生成 html 字符串，再发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的 body 里为空，之后执行 js 将 html 结构注入到 body 里，结合 css 显示出来;

**SSR 的优势：**

- 对 SEO 友好
- 所有的模版、图片等资源都存在服务器端
- 一个 html 返回所有数据
- 减少 HTTP 请求
- 响应快、用户体验好、首屏渲染快

**1）更利于 SEO**

不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本使用了 React 或者其它 MVVM 框架之后，页面大多数 DOM 元素都是在客户端根据 js 动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行 JavaScript 脚本的最终 HTML，网络爬中就可以抓取到完整页面的信息。

**2）更利于首屏渲染**

首屏的渲染是 node 发送过来的 html 字符串，并不依赖于 js 文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。

**SSR 的局限：**

**1）服务端压力较大**

本来是通过客户端完成渲染，现在统一到服务端 node 服务去做。尤其是高并发访问的情况，会大量占用服务端 CPU 资源;

**2）开发条件受限**

在服务端渲染中，只会执行到 componentDidMount 之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;

**3）学习成本相对较高**

除了对 webpack、MVVM 框架要熟悉，还需要掌握 node、 Koa2 等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。

**时间耗时比较：**

**1）数据请求**

由服务端请求首屏数据，而不是客户端请求首屏数据，这是"快"的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网 http 请求开销大，导致时间差

- 客户端数据请求

![51612599334_.pic.jpg](https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1612599697115-b749fd70-9747-4f83-a836-72f46f5e91de.jpeg)

- 服务端数据请求

![61612599340_.pic.jpg](https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1612599745397-099cca87-5c01-4c45-94ad-318b054b7a01.jpeg)

**2）html 渲染**

服务端渲染是先向后端服务器请求数据，然后生成完整首屏 html 返回给浏览器；而客户端渲染是等 js 代码下载、加载、解析完成后再请求数据渲染，等待的过程页面是什么都没有的，就是用户看到的白屏。就是服务端渲染不需要等待 js 代码下载完成并请求数据，就可以返回一个已有完整数据的首屏页面。

- 非 ssr html 渲染

![31612599269_.pic.jpg](https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1612599842432-0b804ffa-177b-43c8-a973-d633917b784b.jpeg)

- ssr html 渲染

![41612599275_.pic.jpg](https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1612599902197-a00e3b91-390f-47b7-856f-b1f2d5c782f7.jpeg)

### 37. React 中的高阶组件运用了什么设计模式？

使用了装饰模式，高阶组件的运用：

```
function withWindowWidth(BaseComponent) {
  class DerivedClass extends React.Component {
    state = {
      windowWidth: window.innerWidth,
    }
    onResize = () => {
      this.setState({
        windowWidth: window.innerWidth,
      })
    }
    componentDidMount() {
      window.addEventListener('resize', this.onResize)
    }
    componentWillUnmount() {
      window.removeEventListener('resize', this.onResize);
    }
    render() {
      return <BaseComponent {...this.props} {...this.state}/>
    }
  }
  return DerivedClass;
}
const MyComponent = (props) => {
  return <div>Window width is: {props.windowWidth}</div>
};
export default withWindowWidth(MyComponent);
```

装饰模式的特点是不需要改变 被装饰对象 本身，而只是在外面套一个外壳接口。JavaScript 目前已经有了原生装饰器的提案，其用法如下：

```
@testable
   class MyTestableClass {
}
```

### 38. 对 React 和 Vue 的理解，它们的异同

**相似之处：**

- 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库
- 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。
- 都使用了 Virtual DOM（虚拟 DOM）提高重绘性能
- 都有 props 的概念，允许组件间的数据传递
- 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性

**不同之处：**

**1）数据流**

Vue 默认支持数据双向绑定，而 React 一直提倡单向数据流

**2）虚拟 DOM**

Vue2.x 开始引入"Virtual DOM"，消除了和 React 在这方面的差异，但是在具体的细节还是有各自的特点。

- Vue 宣称可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。
- 对于 React 而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate 这个生命周期方法来进行控制，但 Vue 将此视为默认的优化。

**3）组件化**

React 与 Vue 最大的不同是模板的编写。

- Vue 鼓励写近似常规 HTML 的模板。写起来很接近标准 HTML 元素，只是多了一些属性。
- React 推荐你所有的模板通用 JavaScript 的语法扩展——JSX 书写。

具体来讲：React 中 render 函数是支持闭包特性的，所以我们 import 的组件在 render 中可以直接调用。但是在 Vue 中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。

**4）监听数据变化的实现原理不同**

- Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能
- React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的 vDOM 的重新渲染。这是因为 Vue 使用的是可变数据，而 React 更强调数据的不可变。

**5）高阶组件**

react 可以通过高阶组件（Higher Order Components-- HOC）来扩展，而 vue 需要通过 mixins 来扩展。

原因高阶组件就是高阶函数，而 React 的组件本身就是纯粹的函数，所以高阶函数对 React 来说易如反掌。相反 Vue.js 使用 HTML 模板创建视图组件，这时模板无法有效的编译，因此 Vue 不采用 HOC 来实现。

**6）构建工具**

两者都有自己的构建工具

- React ==> Create React APP
- Vue ==> vue-cli

**7）跨平台**

- React ==> React Native
- Vue ==> Weex

### 39 说说 React 性能优化的手段有哪些？

在 React 中如何避免不必要的 render (opens new window)中，我们了解到如何避免不必要的 render 来应付上面的问题，主要手段是通过 shouldComponentUpdate、PureComponent、React.memo，这三种形式这里就不再复述

除此之外， 常见性能优化常见的手段有如下：

- 避免使用内联函数

- 使用 React Fragments 避免额外标记

- 使用 Immutable

- 懒加载组件

- 事件绑定方式

- 服务端渲染

#### (1)避免使用内联函数

如果我们使用内联函数，则每次调用 render 函数时都会创建一个新的函数实例，如下：

```
import React from "react";

export default class InlineFunctionComponent extends React.Component {
  render() {
    return (
      <div>
        <h1>Welcome Guest</h1>
        <input type="button" onClick={(e) => { this.setState({inputValue: e.target.value}) }} value="Click For Inline Function" />
      </div>
    )
  }
}
```

我们应该在组件内部创建一个函数，并将事件绑定到该函数本身。这样每次调用 render 时就不会创建单独的函数实例，如下：

```
import React from "react";

export default class InlineFunctionComponent extends React.Component {

  setNewStateData = (event) => {
    this.setState({
      inputValue: e.target.value
    })
  }

  render() {
    return (
      <div>
        <h1>Welcome Guest</h1>
        <input type="button" onClick={this.setNewStateData} value="Click For Inline Function" />
      </div>
    )
  }
}
```

#### (2)使用 React Fragments 避免额外标记

用户创建新组件时，每个组件应具有单个父标签。父级不能有两个标签，所以顶部要有一个公共标签，所以我们经常在组件顶部添加额外标签 div

这个额外标签除了充当父标签之外，并没有其他作用，这时候则可以使用 fragement

其不会向组件引入任何额外标记，但它可以作为父级标签的作用，如下所示：

```javascript
export default class NestedRoutingComponent extends React.Component {
  render() {
    return (
      <>
        <h1>This is the Header Component</h1>
        <h2>Welcome To Demo Page</h2>
      </>
    );
  }
}
```

#### (3)事件绑定方式

在事件绑定方式 (opens new window)中，我们了解到四种事假绑定的方式

从性能方面考虑，在 render 方法中使用 bind 和 render 方法中使用箭头函数这两种形式在每次组件 render 的时候都会生成新的方法实例，性能欠缺

而 constructor 中 bind 事件与定义阶段使用箭头函数绑定这两种形式只会生成一个方法实例，性能方面会有所改善

#### (4)使用 Immutable

在理解 Immutable 中 (opens new window)，我们了解到使用 Immutable 可以给 React 应用带来性能的优化，主要体现在减少渲染的次数

在做 react 性能优化的时候，为了避免重复渲染，我们会在 shouldComponentUpdate()中做对比，当返回 true 执行 render 方法

Immutable 通过 is 方法则可以完成对比，而无需像一样通过深度比较的方式比较

#### (5)懒加载组件

从工程方面考虑，webpack 存在代码拆分能力，可以为应用创建多个包，并在运行时动态加载，减少初始包的大小

而在 react 中使用到了 Suspense 和 lazy 组件实现代码拆分功能，基本使用如下：

```javascript
const johanComponent = React.lazy(() =>
  import(/* webpackChunkName: "johanComponent" */ "./myAwesome.component")
);

export const johanAsyncComponent = (props) => (
  <React.Suspense fallback={<Spinner />}>
    <johanComponent {...props} />
  </React.Suspense>
);
```

#### (6)服务端渲染

采用服务端渲染端方式，可以使用户更快的看到渲染完成的页面

服务端渲染，需要起一个 node 服务，可以使用 express、koa 等，调用 react 的 renderToString 方法，将根组件渲染成字符串，再输出到响应中

例如：

```
import { renderToString } from "react-dom/server";
import MyPage from "./MyPage";
app.get("/", (req, res) => {
  res.write("<!DOCTYPE html><html><head><title>My Page</title></head><body>");
  res.write("<div id='content'>");
  res.write(renderToString(<MyPage/>));
  res.write("</div></body></html>");
  res.end();
});
客户端使用render方法来生成HTML

import ReactDOM from 'react-dom';
import MyPage from "./MyPage";
ReactDOM.render(<MyPage />, document.getElementById('app'));
```

#### 其他

除此之外，还存在的优化手段有组件拆分、合理使用 hooks 等性能优化手段...

### 40. React.lazy() 实现的原理

React 的懒加载示例：

```
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

React.lazy 原理

以下 React 源码基于 16.8.0 版本

React.lazy 的源码实现如下：

```
export function lazy<T, R>(ctor: () => Thenable<T, R>): LazyComponent { let lazyType = { $$typeof: REACT_LAZY_TYPE, _ctor: ctor, // React uses these fields to store the result. _status: -1, _result: null, };

return lazyType; }
```

可以看到其返回了一个 LazyComponent 对象。

而对于 LazyComponent 对象的解析：

```

case LazyComponent: {
  const elementType = workInProgress.elementType;
  return mountLazyComponent(
    current,
    workInProgress,
    elementType,
    updateExpirationTime,
    renderExpirationTime,
  );
}
function mountLazyComponent(
  _current,
  workInProgress,
  elementType,
  updateExpirationTime,
  renderExpirationTime,
) {
  ...
  let Component = readLazyComponentType(elementType);
  ...
}
// Pending = 0, Resolved = 1, Rejected = 2
export function readLazyComponentType<T>(lazyComponent: LazyComponent<T>): T {
  const status = lazyComponent._status;
  const result = lazyComponent._result;
  switch (status) {
    case Resolved: {
      const Component: T = result;
      return Component;
    }
    case Rejected: {
      const error: mixed = result;
      throw error;
    }
    case Pending: {
      const thenable: Thenable<T, mixed> = result;
      throw thenable;
    }
    default: { // lazyComponent 首次被渲染
      lazyComponent._status = Pending;
      const ctor = lazyComponent._ctor;
      const thenable = ctor();
      thenable.then(
        moduleObject => {
          if (lazyComponent._status === Pending) {
            const defaultExport = moduleObject.default;
            lazyComponent._status = Resolved;
            lazyComponent._result = defaultExport;
          }
        },
        error => {
          if (lazyComponent._status === Pending) {
            lazyComponent._status = Rejected;
            lazyComponent._result = error;
          }
        },
      );
      // Handle synchronous thenables.
      switch (lazyComponent._status) {
        case Resolved:
          return lazyComponent._result;
        case Rejected:
          throw lazyComponent._result;
      }
      lazyComponent._result = thenable;
      throw thenable;
    }
  }
}
```

注：如果 readLazyComponentType 函数多次处理同一个 lazyComponent，则可能进入 Pending、Rejected 等 case 中。

从上述代码中可以看出，对于最初 React.lazy() 所返回的 LazyComponent 对象，其 \_status 默认是 -1，所以首次渲染时，会进入 readLazyComponentType 函数中的 default 的逻辑，这里才会真正异步执行 import(url)操作，由于并未等待，随后会检查模块是否 Resolved，如果已经 Resolved 了（已经加载完毕）则直接返回 moduleObject.default（动态加载的模块的默认导出），否则将通过 throw 将 thenable 抛出到上层。

为什么要 throw 它？这就要涉及到 Suspense 的工作原理，我们接着往下分析。

Suspense 原理

由于 React 捕获异常并处理的代码逻辑比较多，这里就不贴源码，感兴趣可以去看 throwException 中的逻辑，其中就包含了如何处理捕获的异常。简单描述一下处理过程，React 捕获到异常之后，会判断异常是不是一个 thenable，如果是则会找到 SuspenseComponent ，如果 thenable 处于 pending 状态，则会将其 children 都渲染成 fallback 的值，一旦 thenable 被 resolve 则 SuspenseComponent 的子组件会重新渲染一次。

为了便于理解，我们也可以用 componentDidCatch 实现一个自己的 Suspense 组件，如下：

```
class Suspense extends React.Component {
  state = {
    promise: null
  }

  componentDidCatch(err) {
    // 判断 err 是否是 thenable
    if (err !== null && typeof err === 'object' && typeof err.then === 'function') {
      this.setState({ promise: err }, () => {
        err.then(() => {
          this.setState({
            promise: null
          })
        })
      })
    }
  }

  render() {
    const { fallback, children } = this.props
    const { promise } = this.state
    return <>{ promise ? fallback : children }</>
  }
}
```

至此，我们分析完了 React 的懒加载原理。简单来说，React 利用 React.lazy 与 import()实现了渲染时的动态加载 ，并利用 Suspense 来处理异步加载资源时页面应该如何显示的问题。
